.. !split

.. _fdm-for-wave:refl:

Обобщения: отражающие границы
=============================

Граничные условия :math:`u = 0` для волнового уравнения означают
отражение волны, но при этом :math:`u` меняет знак на границе, условие
же :math:`\frac{\partial u}{\partial x} = 0` на границе означает
отражение волны с сохранением знака решения.

.. index::
   single: Граничные условия; Неймана

.. index::
   single: Граничные условия; Дирихле

Следующая задача, которую мы рассмотрим заключается в реализации
граничного условия второго рода (*условие Неймана*)
:math:`\frac{\partial u}{\partial x} = 0`, которое 
является более сложным для численной реализации, чем *условие Дирихле*,
т.е. при заданном значении :math:`u` на границе. Ниже мы приведем два
способа разностной аппроксимации условий Неймана: один из них
основан на построении модифицированного шаблона вблизи границы, а
второй основан на расширении сетки мнимыми ячейками и узлами.

.. _fdm-for-wave:refl:neumann:

Граничные условия Неймана
-------------------------

Для описания процесса, когда волна ударяется в границу и отражается
назад, используется условие

.. _Eq:fdm-for-wave:refl:eq:neumann:

.. math::

    \tag{27}
    \frac{\partial u}{\partial \mathbf{n}} \equiv \mathbf{n} \cdot
           \nabla u = 0,
        

где :math:`\partial/\partial\mathbf{n}` --- производная вдоль нормали,
внешней к границе. В одномерном случае (отрезок :math:`[0,l]`), имеем

.. math::
        
           \frac{\partial}{\partial\mathbf{n}}\Bigg|_{x = l} =
           \frac{\partial}{\partial x}, \quad
           \frac{\partial}{\partial\mathbf{n}}\Bigg|_{x = 0} =
           -\frac{\partial}{\partial x}
        

.. _fdm-for-wave:refl:deriv_appr:

Аппроксимация производной на границе
------------------------------------

Построим аппроксимацию граничного условия 
:ref:`(27) <Eq:fdm-for-wave:refl:eq:neumann>` со
вторым порядком аппроксимации по пространственной переменной. Для
этого воспользуемся центральной разностной производной:

.. _Eq:fdm-for-wave:refl:eq:neumann_appr:

.. math::

    \tag{28}
    y_{\mathring{x},0}^n = \frac{y_{1}^n - y_{-1}^n}{2h} = 0.
        

Проблема заключается в том, что :math:`y_{-1}^n` не является расчетным
значением, так как задано в нерасчетном узле не принадлежащем
сетке. Однако, если мы объединим 
:ref:`(28) <Eq:fdm-for-wave:refl:eq:neumann_appr>` с разностным
уравнением :ref:`(8) <Eq:fdm-for-wave:string_eq:eq:fds_rec>`, записанным в узле
:math:`i = 0`: 

.. _Eq:fdm-for-wave:refl:eq:fds_0:

.. math::

    \tag{29}
    y_0^{n+1} = 2y_0^{n} - y_0^{n-1} + \gamma^2 (y_{1}^n - 2y_{0}^n +
           y_{-1}^n),
        

мы можем исключить фиктивное значение :math:`y_{-1}^n`. Учитывая
:ref:`(28) <Eq:fdm-for-wave:refl:eq:neumann_appr>`, имеем :math:`y_{-1}^n = y_1^n`. Подставив
последнее в 
:ref:`(29) <Eq:fdm-for-wave:refl:eq:fds_0>`, получим модифицированное уравнение в
граничной точке :math:`y_0^{n+1}`:

.. _Eq:fdm-for-wave:refl:eq:neumann_modif:

.. math::

    \tag{30}
    y_0^{n+1} = 2y_0^{n} - y_0^{n-1} + 2\gamma^2 (y_{1}^n - 2y_{0}^n).
        

На рис. :ref:`fdm-for-wave:refl:fig:1` представлен шаблон схемы на левой
границе области с учетом аппроксимации условия Неймана.

.. _fdm-for-wave:refl:fig:1:

.. figure:: wave_bound_templ.png
   :width: 300

   *Модифицированный шаблон на левой границе для аппроксимации условия Неймана*

Аналогично, получаем апрокссимацию условия 
:ref:`(27) <Eq:fdm-for-wave:refl:eq:neumann>` на
правой границе :math:`x = l`:

.. math::
        
           y_{\mathring{x},N} = \frac{y_{N+1}^n - y_{N-1}^n}{2h} = 0
        

Объединяя последнее с разностным уравнением :ref:`(8) <Eq:fdm-for-wave:string_eq:eq:fds_rec>`
при :math:`i = N` получим модифицированное уравнение на правой
границе:

.. math::
        
           y_N^{n+1} = 2y_N^n - y_N^{n-1} + 2\gamma^2(y_{N-1}^n - y_{N}^n).
        

Кроме того, на границах нужно построить модификацию разностного
уравнения :ref:`(11) <Eq:fdm-for-wave:string_eq:eq:y1>` для вычисления значений
на первом временном шаге.

.. _fdm-for-wave:refl:impl:

Программная реализация условий Неймана
--------------------------------------

В предыдущем пункте мы вывели специальные формулы для расчета вблизи
границ. При этом, учитывая аппроксимацию условий Неймана центральной
разностной производной, мы заменили значения :math:`y_{-1}^n` на
:math:`y_{1}^n` на левой границе и :math:`y_{N+1}^n` на
:math:`y_{N-1}^n` на правой границе. Эти наблюдения могут легко
использоваться при программной реализации: мы можем просто
использовать общий шаблон во всех узлах сетки, но написать код так,
чтобы можно было легко заменить ``y[i-1]`` на ``y[i+1]`` и наоборот. Этого
можно добиться задавая индексы ``i+1`` и ``i-1`` как переменные ``ip1`` (``i``
plus ``1``) и ``im1`` (``i`` minus ``1``), соответственно. Следовательно на
левой границе мы можем определить ``im1 = i+1``, в то время как во
внутренних узлах сетки ``im1 = i-1``. Ниже представлена программная
реализация такого подхода:

.. code-block:: python

    i = 0
    ip1 = i+1
    im1 = ip1  # i-1 -> i+1
    y[i] = y_1[i] + gamma2*(y_1[im1] - 2*y[i] + y_1[ip1])
    
    i = N
    im1 = i-1
    ip1 = im1  # i+1 -> i-1
    y[i] = y_1[i] + gamma2*(y_1[im1] - 2*y[i] + y_1[ip1])

На самом деле мы можем создать один цикл как для граничных, так и для
внутренних узлов и использовать одну формулу для вычисления значений
на новом временном слое:

.. code-block:: python

    for i in range(0, N+1):
    	ip1 = i+1 if i < N+1 else i-1
    	im1 = i-1 if i > 0 else i+1
    	y[i] = y_1[i] + gamma2*(y_1[im1] - 2*y[i] + y_1[ip1])

Сценарий `wave1d_n0.py <src-fdm-for-wave/wave1d_n0.py>`__ содержит
полную программную реализацию решения одномерного волнового уравнения
с граничными условиями Неймана. В нем реализован тест, использующий
«волну-вилку» в качестве начального данного и проверяющий, что
начальное состояние возвращается после одного периода. Но такой тест
требует выполнения условия :math:`\gamma = 1`, так как в этом случае
численное решение совпадает с точным решением дифференциальной
задачи.

.. _fdm-for-wave:refl:idx_set:

Обозначение множеств индексов
-----------------------------

Для того, чтобы улучшить математическую запись и программную
реализацию, полезно ввести обозначения для множеств индексов. Это
означает, что мы будем писать :math:`x`, :math:`i\in \mathcal{I}_x`
вместо :math:`i = 0, 1, \ldots, N`. Очевидно, что
:math:`\mathcal{I}_x` должно быть множеством индексов
:math:`\mathcal{I}_x = \{ 0, 1, \ldots, N\}`, но часто удобно
использовать символ для этого множества, чем указывать все элементы
этого множества. Такие обозначения делают описания алгоритмов и их
программную реализацию более простыми.

Первый элемент этого множества будем обозначать
:math:`\mathcal{I}_x^0`, а последний :math:`\mathcal{I}_x^{-1}`. Если
нужно отбросить первый элемент множества, то будем использовать символ
:math:`\mathcal{I}_x^+` для остального подмножества
:math:`\mathcal{I}_x^+ = \{1, 2, \ldots, N\}`. Аналогично,
:math:`\mathcal{I}_x^- = \{0, 1, \ldots, N-1\}`. Все индексы
соответствующие внутренним узлам сетки обозначим
:math:`\mathcal{I}_x^i =\{1, 2, \ldots, N-1\}`.

В коде на Python для множеств индексов будет следующее соответствие:

==========================  ============  
       Обозначение             Python     
==========================  ============  
:math:`\mathcal{I}_x`       ``Ix``        
==========================  ============  
:math:`\mathcal{I}^0_x`     ``Ix[0]``     
==========================  ============  
:math:`\mathcal{I}^{-1}_x`  ``Ix[-1]``    
==========================  ============  
:math:`\mathcal{I}^-_x`     ``Ix[:-1]``   
==========================  ============  
:math:`\mathcal{I}^+_x`     ``Ix[1:]``    
==========================  ============  
:math:`\mathcal{I}^i_x`     ``Ix[1:-1]``  
==========================  ============  


.. admonition:: Почему полезны множества индексов

   Важная характерная особенность использования множеств индексов
   заключается в том, что формулы и код программы не зависят от
   порядка нумерации узлов сетки. Например, обозначение :math:`i \in
   \mathcal{I}_x` или :math:`i \in \mathcal{I}_x^0` остается
   одинаковым и для :math:`\mathcal{I}_x`, определенном выше, и для
   :math:`\mathcal{I}_x = \{1, 2, \ldots, Q\}`. Аналогично, в коде мы
   можем определить ``Ix = range(N+1)`` или ``Ix = range(1,Q)``, а
   выражения типа ``Ix[0]`` и ``Ix[1:-1]`` остаются корректными. Один
   из примеров удобства использования такого подхода --- это
   преобразование кода, написанного на языке, где нумерация массивов
   начинается с нуля (например, Python или C), в код на языке, где нумерация
   массивов начинается с единицы (например, MATLAB или
   Fortran). Другое важное применение --- это реализация условий
   Неймана с помощью мнимых узлов.




В рассматриваемой нами задаче используются следующие множества
индексов:

.. math::
        
           \mathcal{I}_x = \{ 0, 1, \ldots, N\}, \\ 
           \mathcal{I}_t = \{ 0, 1, \ldots, K\}, \\ 
        

определяемые в Python следующим образом:

.. code-block:: python

    Ix = range(0, N+1)
    It = range(0, K+1)

Используя множества индексов, разностную схему можно записать
следующим образом:

.. math::
        
        \begin{split}
           y_i^{n+1} &= y_i^n - \frac{1}{2} \gamma^2(y_{i+1}^n - 2y_i^n +
           y_{i-1}^n), \quad i \in \mathcal{I}_x, \quad n = 0, \\ 
           y_i^{n+1} &= 2y_i^{n-1} - y_i^n + \gamma^2(y_{i+1}^n - 2y_i^n +
           y_{i-1}^n), \quad i \in \mathcal{I}_x^i, \quad n \in
           \mathcal{I}_t^i, \\ 
           y_i^{n+1} &= 0, \quad i = \mathcal{I}_x^0, \quad t \in \mathcal{I}_t^-,\\ 
           y_i^{n+1} &= 0, \quad i = \mathcal{I}_x^{-1}, \quad t \in \mathcal{I}_t^-.
        \end{split}
        

Соответствующий программный код имеет вид:

.. code-block:: python

    # Начальные условия
    for i in Ix[1:-1]:
    	y[i] = y_1[i] - 0.5*gamma2*(y_1[i+1] - 2*y_1[i] + y_1[i-1])
    
    # Цикл по времени
    for i in It[1:-1]:
    	# Вычисление значений во внутренних узлах
    	for i in Ix[1:-1]:
    		y[i] = 2*y_2[i] - y_1[i] + \ 
    		       gamma2*(y_1[i+1] - 2*y_1[i] + y_1[i-1])
    	# Вычисление граничных условий
    	i = Ix[0]; y[i] = 0
    	i = Ix[-1]; y[i] = 0


.. note::
   Сценарий `wave1d_n.py <src-fdm-for-wave/wave1d_n.py>`__ использует
   множества индексов и решает одномерное волновое уравнение с
   достаточно общими граничными и начальными условиями:
   
   * :math:`x = 0`: :math:`u = u_l(t)` или :math:`\frac{\partial u}{\partial x} = 0`;
   
   * :math:`x = l`: :math:`u = u_r(t)` или :math:`\frac{\partial u}{\partial x} = 0`;
   
   * :math:`t = 0`: :math:`u = I(x)`;
   
   * :math:`t = 0`: :math:`\frac{\partial u}{\partial t} = V(x)`.
   
   Сценарий объединяет условия Дирихле и Неймана, скалярную и
   векторизованную реализацию разностной схемы, а также множества
   индексов. Большое количество тестовых примеров также включены в
   этот сценарий:
   
   * начальное условие в форме «волны-вилки» (при :math:`\gamma=1` решением будет прямоугольник смещающийся на одну ячейку за временной шаг);
   
   * начальное условие как функция Гаусса;
   
   * начальное условие в форме треугольного профиля, который похож на начальное положение гитарной струны;
   
   * синусоидальное изменение решения при :math:`x=0` и либо :math:`u = 0`, либо :math:`\frac{\partial u}{\partial x} = 0` при :math:`x = l`;
   
   * точное аналитическое решение :math:`u(x, t) = \cos\frac{m\pi t}{l} \sin \frac{m\pi x}{2l}`, которое может использоваться для проверки скорости сходимости.




.. _fdm-for-wave:refl:ver:

Верификация реализации граничных условий Неймана
------------------------------------------------

Перейдем к вопросу тестирования реализации условий Неймана. Функция
``solver`` `wave1d_n.py <src-fdm-for-wave/wave1d_n.py>`__
реализованы как условия Дирихле и 
Неймана при :math:`x = 0` и :math:`x = l`. Заманчиво было бы
использовать решение типа квадратичной функции, однако эта функция не
является точным решением задачи с условиями Неймана. Линейная функция
также не подходит, так как реализованы только однородные условия
Неймана, поэтому для тестирования будем использовать только постоянное
решение :math:`u = \mathrm{const}`.

.. code-block:: python

    def test_constant():
        """
        Тестируем работу скалярной и векторизованой версий
        для постоянного u(x,t). Выполняем расчет на отрезке
        [0, l] и применяем условия Неймана и Дирихле на обоих 
        границах.
        """
        u_const = 0.45
        u_exact = lambda x, t: u_const
        I = lambda x: u_exact(x, 0)
        V = lambda x: 0
        f = lambda x, t: 0
    
        def assert_no_error(y, x, t, n):
            u_e = u_exact(x, t[n])
            diff = np.abs(y - u_e).max()
            msg = 'diff=%E, t_%d=%g' % (diff, n, t[n])
            tol = 1E-13
            assert diff < tol, msg
    
        for ul in (None, lambda t: u_const):
            for ur in (None, lambda t: u_const):
                l = 2.5
                c = 1.5
                gamma = 0.75
                N = 3  # Очень грубая сетка для точного теста
                tau = gamma*(l/N)/c
                T = 18  
    
                solver(I, V, f, c, ul, ur, l, tau, gamma, T,
                       user_action=assert_no_error,
                       version='scalar')
                solver(I, V, f, c, ul, ur, l, tau, gamma, T,
                       user_action=assert_no_error,
                       version='vectorized')
                print ul, ur

Другой тест основан на том факте, что погрешность аппроксимации равна
нулю в случае когда число Куранта равно единице. Возьмем в качестве
начальной функции «волну-площадку», пусть начальная функция
распадается на две площадки, каждая смещается в своем
направлении. Проверит, что эти две волны отразятся от границ и
сформируют начальное распределение после одного
периода. Соответствующая тестовая функция представлена ниже

.. code-block:: python

    def test_plug():
        """Тестирование возвращается для профиль-площадка после одного периода."""
        l = 1.0
        c = 0.5
        tau = (l/10)/c  # N=10
        I = lambda x: 0 if abs(x-l/2.0) > 0.1 else 1
    
        u_s, x, t, cpu = solver(
            I=I,
            V=None, f=None, c=0.5, ul=None, ur=None, l=l,
            tau=tau, gamma=1, T=4, user_action=None, version='scalar')
        u_v, x, t, cpu = solver(
            I=I,
            V=None, f=None, c=0.5, ul=None, ur=None, l=l,
            tau=tau, gamma=1, T=4, user_action=None, version='vectorized')
        tol = 1E-13
        diff = abs(u_s - u_v).max()
        assert diff < tol
        u_0 = np.array([I(x_) for x_ in x])
        diff = np.abs(u_s - u_0).max()
        assert diff < tol

Остальные тесты используются для анализа погрешности аппроксимации.

.. index:: Мнимые ячейки

.. index:: Мнимые узлы

.. index:: Мнимые значения

.. _fdm-for-wave:refl:ghost:

Реализация граничных условий Неймана с использованием мнимых ячеек
------------------------------------------------------------------

.. _fdm-for-wave:refl:ghost:idea:

Идея
~~~~

Вместо модификации схемы на границе мы можем ввести дополнительные
узлы вне области задачи, так что фиктивные значения :math:`y_{-1}^n`
и :math:`u_{N+1}^n` будут определены на сетке. Добавление интервалов
:math:`[-h, 0]` и :math:`[l+h,0]`, назовем их *мнимые ячейки* к
расчетной сетке дает все узлы сетки, соответствующие :math:`i = -1, 2, 
\ldots, N+1`. Дополнительные узлы :math:`i =-1` и :math:`i = N+1`
назовем *мнимыми узлами*, а значения в этих узлах :math:`y_{-1}^{n}`
и :math:`y_{N+1}^n` назовем *мнимыми значениями*

Основная идея состоит в том, чтобы быть уверенным, что всегда будет
выполняться

.. math::
        
           u_{-1}^n = u_{1}^n \quad \textrm{и}\quad u_{N+1}^n = u_{N-1}^n,
        

потому что тогда использование стандартной разностной схемы в узлах
:math:`i = 0` и :math:`i = N` будет корректным и будет гарантировать,
что решение согласуется с граничным условием Неймана.

.. _fdm-for-wave:refl:ghost:impl:

Программная реализация          (2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Массив ``y``, содержащий решение, должен содержать дополнительные
элементы с мнимыми узлами:

.. code-block:: python

    y = zeros(N+3)

Массивы ``y_1`` и ``y_2`` необходимо определить аналогично.

К сожалению стандартная индексация массивов в Python (индексация
начинается с 0), не удобна в случае использования рассматриваемого
подхода. В этом случае возникает несоответствие математической
индексации :math:`i = -1, 0, 1, \ldots, N+1` и индексации
Python ``0, 1, ..., N+2``. Один способ решения этой проблемы состоит в
изменении математической нумерации в разностной схеме и записать

.. math::
        
           y_i^{n+1} = \ldots, \quad i = 1, 2, \ldots, N + 1
        

вместо :math:`i = 0, 1, \ldots, N`. В этом случае номера мнимых узлов
будут :math:`i=0` и :math:`i = N+2`. Можно предложить решение лучше
основанное на использовании множеств индексов: мы скроем значения
индексов и будем оперировать понятиями внутренних и граничных узлов.

С этой целью мы определим ``y`` нужной длины и ``Ix`` ---
соответствующие индексы реальных узлов

.. code-block:: python

    y   = np.zeros(N+3)
    Ix = range(1, u.shape[0]-1)

Это значит, что граничные узлы будут иметь индексы ``Ix[0]`` и
``Ix[-1]`` (как и раньше). Сначала мы вычислим решение физических
узлах (т.е. во внутренних узлах сетки):

.. code-block:: python

            for i in Ix:
                y[i] = - y_2[i] + 2*y_1[i] + \ 
                       gamma2*(y_1[i-1] - 2*y_1[i] + y_1[i+1]) + \ 
                       tau2*f(x[i-Ix[0]], t[n])

Такое индексирование будет сложнее при вызове функций ``V(x)`` и
``f(x,t)``, так как соответствующая координата :math:`x` задана как
``x[i - Ix[0]]``:

.. code-block:: python

        for i in Ix:
            y[i] = y_1[i] + tau*V(x[i-Ix[0]]) + \ 
                   0.5*gamma2*(y_1[i-1] - 2*y_1[i] + y_1[i+1]) + \ 
                   0.5*tau2*f(x[i-Ix[0]], t[0])

Осталось обновить решение в мнимых узлах, т.е. ``y[0]`` и ``y[-1]``
(или ``y[N+2]``). Для граничного условия Неймана
:math:`\frac{\partial u}{\partial x} = 0`, значения в мнимых узлах
должны быть равны значениям в соответствующих внутренних узлах. Ниже
приведен соответствующий фрагмент кода:

.. code-block:: python

            # Мнимые значения устанавливаем в соответствии с du/dx=0
            i = Ix[0]
            y[i-1] = y[i+1]
            i = Ix[-1]
            y[i+1] = y[i-1]

Решение, график которого будем строить --- срез ``y[1:-1]``
или ``y[Ix[0]:Ix[-1]+1]``. Этот срез будет возвращать функция
``solver``. Полностью программную реализацию этого подхода можно найти
в файле `wave1d_n_ghost.py <src-fdm-for-wave/wave1d_n_ghost.py>`__.


.. warning::
    Необходимо быть аккуратным с тем, как хранить сетки по пространству
    и времени. Пусть ``x`` --- физические узлы
    
    .. code-block:: python
    
        x = linspace(0, l, N+1)
    
    «Стандартная реализация» начальных данных
    
    .. code-block:: python
    
        for i in Ix:
        	y_1[i] = I(x[i])
    
    становится в этом случае ошибочной, так как ``y_1`` и ``x`` имеют
    разные длины и индекс ``i`` соответствует двум различным узлам
    сетки. На самом деле, ``x[i]`` соответствует
    ``y_1[i+1]``. Правильная реализация имеет вид
    
    .. code-block:: python
    
        for i in Ix:
        	y_1[i] = I(x[i - Ix[0]])
    
    Аналогично, использование при вычислении правой части выражения
    ``f(x[i], t[n])`` неправильно, если ``x`` определено на множестве
    физических точек. Следовательно, ``x[i]`` нужно заменить на
    ``x[i - Ix[0]]``.
    
    Альтернативный способ решения этой проблемы --- задать массив ``x``
    так, чтобы он содержал мнимые точки и ``y[i]`` было значением в
    ``x[i]``.




Мнимые ячейки добавляются только к границам, на которых заданы условия
Неймана. Предположим, что на :math:`x=l` задано условие Дирихле, а на
:math:`x=0` --- условие Неймана. В этом случае к сетке добавляется
одна мнимая ячейка :math:`[-h, 0]`, поэтому множестве индексов для
физических узлов --- :math:`\{1, 2, \ldots, N+1\}`. Ниже представлен
соответствующий фрагмент кода:

.. code-block:: python

    y = zeros(N+2)
    Ix = range(1, y.shape[0])
    ...
    for i in Ix[:-1]:
    	y[i] = 2*y_1[i] - y_2[i] + \ 
    	gamma2*(y_1[i-1] - 2y[i] + y[i+1]) + \ 
    	tau2*f(x[i-Ix[0]], t[n])
    i = Ix[-1]
    y[i] = ur   # условия Дирихле
    i = Ix[0]
    y[i-1] = y[i+1]   # условие Неймана

Физическое решение, график которого будет строится, --- ``y[1:]`` или
``y[Ix[0]:Ix[-1]+1]``.

.. Local Variables:

.. doconce-chapter-nickname: "fdm-for-wave"

.. doconce-section-nickname: "refl"

.. End:

.. _fdm-for-wave:varvel:

Обобщения: переменная скорость распространения волны
====================================================

Следующее обобщение одномерного волнового уравнения
:ref:`(1) <Eq:fdm-for-wave:string_eq:eq:string>` или
:ref:`(12) <Eq:fdm-for-wave:verif:eq:string_unhom>` --- введение 
переменной скорости распространения волны :math:`c = c(x)`. Такое
уравнение описывает процесс протекающий в областях состоящих из сред с
разными физическими свойствами. Когда среды отличаются физическими
свойствами, такими как плотность или пористость, скорость
распространения волны в этом случае зависит от положения в
пространстве.

.. _fdm-for-wave:varvel:model:

Модельное уравнение с переменными коэффициентами
------------------------------------------------

Вместо :math:`c^2(x)` будем использовать более удобное обозначение
:math:`k(x) = c^2(x)` для коэффициента уравнения. Одномерное волновое
уравнение с переменной скоростью распространение волны принимает вид:

.. _Eq:fdm-for-wave:varvel:eq:string:

.. math::

    \tag{31}
    \frac{\partial^2 u}{\partial t^2} = \frac{\partial }{\partial x}
           \left( k(x) \frac{\partial u}{\partial x} \right) + f(x,t).
        

.. _fdm-for-wave:varvel:coeff_appr:

Аппроксимация переменных коэффициентов
--------------------------------------

В случае достаточно гладких коэффициентов и решения дифференциальный оператор
:math:`\frac{\partial }{\partial x} \left( k(x) \frac{\partial u}{\partial
x} \right)` во внутренних узлах сетки будем 
аппроксимировать разностным оператором :math:`(a y_{\bar{x}})_{x}`. Для
аппроксимации со вторым порядком необходимо выбрать коэффициенты
разностного оператора так, чтобы

.. _Eq:fdm-for-wave:varvel:eq:coeff_cond:1:

.. math::

    \tag{32}
    \frac{a_{i+1} - a_i}{h} = k'(x_i) + O(h^2), 
        

.. _Eq:fdm-for-wave:varvel:eq:coeff_cond:2:

.. math::

    \tag{33}
    \frac{a_{i+1} + a_i}{2} = k(x_i) + O(h^2).
        

Этим условиям удовлетворяют, в частности, следующие формулы для
определения :math:`a_i`:

.. _Eq:fdm-for-wave:varvel:eq:coeff:

.. math::

    \tag{34}
    a_i = k_{i-1/2} = k(x_i - 0.5h),
        

.. _Eq:fdm-for-wave:varvel:eq:coeff_arithm:

.. math::

    \tag{35}
    a_i = \frac{k_{i-1} + k_i}{2},
        

.. _Eq:fdm-for-wave:varvel:eq:coeff_harm:

.. math::

    \tag{36}
    a_i = 2 \left( \frac{1}{k_{i-1}} + \frac{1}{k_i} \right)^{-1}.
        

Выражение 
:ref:`(35) <Eq:fdm-for-wave:varvel:eq:coeff_arithm>` --- среднее арифметическое
значений коэффициента в соседних узлах и часто используется для
гладких коэффициентов, среднее гармоническое 
:ref:`(36) <Eq:fdm-for-wave:varvel:eq:coeff_harm>`
часто используется при аппроксимации коэффициентов с сильно
меняющимися значениями.

Правую часть :math:`f(x,t)` уравнения :ref:`(31) <Eq:fdm-for-wave:varvel:eq:string>`
аппроксимируем следующим образом 

.. math::
        
           \varphi_i^n = f(x_i,t_n).
        

Таким образом, мы можем аппроксимировать уравнение 
:ref:`(31) <Eq:fdm-for-wave:varvel:eq:string>`
на сетке :math:`\omega_{h\tau}` следующей разностной схемой:

.. _Eq:fdm-for-wave:varvel:eq:fds:

.. math::

    \tag{37}
    y_{\bar{t}t} = (a y_{\bar{x}})_{x} + \varphi, \quad (x,t) \in \omega_{h\tau},
        

Осталось выразить из уравнения 
:ref:`(37) <Eq:fdm-for-wave:varvel:eq:fds>` значение
:math:`y_i^{n+1}`:

.. _Eq:fdm-for-wave:varvel:eq:fds_rec:

.. math::

    \tag{38}
    y_i^{n+1} = 2y_i^n - y_i^{n-1} \nonumber 
        

.. math::
          
            + \frac{\tau^2}{h^2} \left( a_{i+1} (y_{i+1}^n - y_{i}^n) -
           a_{i} (y_{i}^n - y_{i-1}^n) \right) \nonumber
        

.. _Eq:_auto1:

.. math::

    \tag{39}
    + \tau^2 \varphi_i^n
        
        

.. _fdm-for-wave:varvel:neumann:

Условия Неймана и переменные коэффициенты
-----------------------------------------

Рассмотрим аппроксимацию условий Неймана на границе :math:`x = l = Nh`:

.. math::
        
           \frac{y_{N+1}^n - y_{N-1}^n}{2h} = 0 \Rightarrow y_{N+1}^n =
           y_{N-1}^n.
        

Записывая разностную схему 
:ref:`(38) <Eq:fdm-for-wave:varvel:eq:fds_rec>` в узле :math:`i = N` и учитывая, что
:math:`y_{N+1} = y_{N-1}`, получим 

.. _Eq:fdm-for-wave:varvel:eq:fds_neumann:

.. math::

    \tag{40}
    y_N^{n+1} = 2 y_{N}^n - y_N^{n-1} \nonumber
        

.. math::
          
           \quad + \frac{\tau^2}{h^2} \left( a_{N+1} (y_{N+1}^n - y_{N}^n) -
           a_{N} (y_{N}^n - y_{N-1}^n) \right) + \tau^2 \varphi_N^n \nonumber
        

.. math::
          
           = 2 y_{N}^n - y_N^{n-1} + \frac{\tau^2}{h^2} \left( (a_{N+1} +
           a_N) (y_{N-1} - y_N) \right) + \tau^2\varphi_i^n \nonumber
        

.. _Eq:_auto2:

.. math::

    \tag{41}
    \approx 2 y_{N}^n - y_N^{n-1} + 2\frac{\tau^2}{h^2} \left(
           a_{N+1/2} (y_{N-1} - y_N) \right) + \tau^2\varphi_N^n.
        
        

Здесь мы использовали условия 
:ref:`(32) <Eq:fdm-for-wave:varvel:eq:coeff_cond:1>`--:ref:`(33) <Eq:fdm-for-wave:varvel:eq:coeff_cond:2>`
и :math:`a_{N+1/2} = k(x_N)`. Кроме того вместо :math:`a_{N+1/2}` можно
использовать :math:`a_N`. 

Выражение 
:ref:`(40) <Eq:fdm-for-wave:varvel:eq:fds_neumann>` с :math:`a_N` вместо
:math:`a_{N+1/2}` можно записать в форме

.. math::
        
           a_N y_{x,N}^n + \frac{h}{2} y_{\bar{t}t,N}^n = \frac{h}{2}
           \varphi_N^n
        

Отметим, что подобные аппроксимации переменных коэффициентов и
граничных условий Неймана мы можем получить, используя
интегро-интерполяционный метод (метод баланса) или метод конечных
элементов.

.. _fdm-for-wave:varvel:more_gen:

Более общее уравнение с переменными коэффициенты
------------------------------------------------

Иногда волновое уравнение содержит переменный коэффициент перед второй
производной по времени:

.. _Eq:fdm-for-wave:varvel:eq:wave_gen:

.. math::

    \tag{42}
    \varrho(x) \frac{\partial^2 u}{\partial t^2} = \frac{\partial }{x} \left( k(x) \frac{\partial u}{\partial \partial x} \right)
        	+ f(x,t).
        

Такое уравнение описывает, например, упругие волны в стержне с
переменной плотностью.

Естественная аппроксимация 
:ref:`(42) <Eq:fdm-for-wave:varvel:eq:wave_gen>` может выглядеть следующим
образом:

.. _Eq:fdm-for-wave:varvel:eq:wave_gen_fds:

.. math::

    \tag{43}
    \varrho y_{\bar{t}t} = \left( a y_{\bar{x}}\right)_x = \varphi, \quad
        (x,t) \in \omega_{h\tau}
        

Очевидно, что коэффициент :math:`\varrho` не добавляет особых трудностей,
так не требует какогло-либо осреднения, а вычисляется в узле сетки.

.. Local Variables:

.. doconce-chapter-nickname: "fdm-for-wave"

.. doconce-section-nickname: "varvel"

.. End:

.. _fdm-for-wave:damping:

Обобщения: затухания
====================

Существует два механизма исчезновения волн. В двумерном и трехмерном
случаях энергия волн распределяется в пространстве, и, следовательно, с
учетом сохранения энергии приходим к тому, что должна уменьшаться
амплитуда колебаний. Этот эффект отсутствует в одномерном
случае. Затухания являются второй причиной уменьшения
амплитуды. Например, колебания струны исчезают из-за затуханий,
обусловленных сопротивлением воздуха и неупругих эффектов в струне.

Простейший способ ввести затухания в модель заключается в добавлении
первой производной по времени в уравнение:

.. _Eq:fdm-for-wave:damping:eq:vibr:

.. math::

    \tag{44}
    \frac{\partial^2 u}{\partial t^2} + b\frac{\partial u}{\partial t} = c^2\frac{\partial^2 u}{\partial x^2} + f(x,t),
        

где :math:`b \geq 0` заданный коэффициент затухания.

Естественную аппроксимацию уравнения 
:ref:`(44) <Eq:fdm-for-wave:damping:eq:vibr>` можно получить, используя
центральную разностную производную

.. _Eq:fdm-for-wave:damping:eq:vibr_fds:

.. math::

    \tag{45}
    y_{\bar{t}t} + b y_{\mathring{t}} = c^2 y_{\bar{x}x} + \varphi.
        

Решая уравнение 
:ref:`(45) <Eq:fdm-for-wave:damping:eq:vibr_fds>` относительно :math:`y_i^{n+1}`,
получим

.. _Eq:fdm-for-wave:damping:eq:vibr_fds_rec:

.. math::

    \tag{46}
    y_i^{n+1} = (1 + 0.5b\tau)^{-1} \left((0.5b\tau - 1)y_i^{n-1} + 2
        	y_i^n + \gamma^2 (y_{i+1}^n - 2y_i^n + y_{i-1}^n) + \varphi_i^n
        	\right), 
        

для :math:`i \in \mathcal{I}_x^i` и :math:`n \geq 1`. Также нужно получить
уравнения для :math:`y_i^1` и для граничных узлов в случае условий Неймана.

Обычно во многих физических процессах затухания являются малыми и
видны только на больших временных отрезках. Этот факт делает
обоснованным использование для большого числа приложений стандартного
волнового уравнения без затуханий.

.. Local Variables:

.. doconce-chapter-nickname: "fdm-for-wave"

.. doconce-section-nickname: "damping"

.. End:

.. _fdm-for-wave:gen_solver:

Разработка общего солвера для одномерного волнового уравнения
=============================================================

Программа `wave1d_dn_vc.py <src-fdm-for-wave/wave1d_dn_vc.py>`__ 
представляет собой довольно общий код для задач одномерного 
распространения волн, который нацелен на следующую начально-краевую
задачу:

.. _Eq:fdm-for-wave:gen_solver:eq:wave:

.. math::

    \tag{47}
    \frac{\partial^2 u}{\partial t^2} = \frac{\partial }{x}\left( c^2(x) \frac{\partial u}{\partial \partial x} \right) + f(x,t), \quad x\in
        	(0,l),\ t \in (0,T],
        

.. _Eq:fdm-for-wave:gen_solver:eq:init:

.. math::

    \tag{48}
    u(x,0) = I(x), \quad x \in [0,l],
        

.. _Eq:fdm-for-wave:gen_solver:eq:init_vel:

.. math::

    \tag{49}
    \frac{\partial u(x,0)}{\partial t} = V(x), \quad x \in [0,l],
        

.. _Eq:fdm-for-wave:gen_solver:eq:left_bound:

.. math::

    \tag{50}
    u(0,t) = U_0(t)\ \textrm{или}\ \frac{\partial u(0,t)}{\partial x}=0, \quad t \in (0, T],
        

.. _Eq:fdm-for-wave:gen_solver:eq:right_bound:

.. math::

    \tag{51}
    u(0,t) = U_l(t)\ \textrm{или}\ \frac{\partial u(l,t)}{\partial x}=0, \quad t \in (0, T].
        

Единственная особенность данной задачи, в сравнении с предыдущей,
состоит в том, что заданы неоднородные условия Дирихле (зависящие от
времени). Реализация этого тривиальная

.. code-block:: python

    i = Ix[0]
    y[i] = ul(t[n+1])
    
    i = Ix[-1]
    y[i] = ur(t[n+1])

Векторизация используется только внутри цикла по времени, а не в
для начальных условиях, так как эта начальная работа незначительна по
сравнению с моделированием больших временных отрезков в одномерном
случае.

.. _fdm-for-wave:gen_solver:solver:

Функция-солвер          (2)
---------------------------

Решение с помощью явной разностной схемы, описанной в
параграфе :ref:`fdm-for-wave:varvel` общей начально-краевой задачи 
:ref:`(47) <Eq:fdm-for-wave:gen_solver:eq:wave>` - :ref:`(51) <Eq:fdm-for-wave:gen_solver:eq:right_bound>`
можно реализовать с помощью функции ``solver`` (см. сценарий
`wave1d_dn_vc.py <src-fdm-for-wave/wave1d_dn_vc.py>`__). Эта функция
расширяет простейшую функцию ``solver`` из сценария
`wave1d_1.py <src-fdm-for-wave/wave1d_1.py>`__, добавлением реализации
условий Неймана, зависящих от времени условий Дирихле, а также
переменной скорости распространения волны:

.. _fdm-for-wave:gen_solver:solver_code:

Код          (1)
~~~~~~~~~~~~~~~~

Ниже представлен код функции ``solver`` из сценария
`wave1d_dn_vc.py <src-fdm-for-wave/wave1d_dn_vc.py>`__:

.. code-block:: python

    def solver(I, V, f, c, ul, ur, l, tau, gamma, T,
               user_action=None, version='scalar',
               stability_safety_factor=1.0):
        """Решается уравнение $u_tt=(c^2*u_x)_x + f$ на $(0,l)\times(0,T]$."""
        Nt = int(round(T/tau))
        t = np.linspace(0, Nt*tau, Nt+1)      # Сетка по времени
    
        # Находим max(c) используя мнимую сетку и адаптируем пространственный
        # шаг h согласно gamma и tau
        if isinstance(c, (float,int)):
            c_max = c
        elif callable(c):
            c_max = max([c(x_) for x_ in np.linspace(0, l, 101)])
        h = tau*c_max/(stability_safety_factor*gamma)
        Nx = int(round(l/h))
        x = np.linspace(0, l, Nx+1)          # Пространственная сетка
    
        # Представляем c(x) как массив
        if isinstance(c, (float,int)):
            c = np.zeros(x.shape) + c
        elif callable(c):
            # Вызываем c(x) и заполняем массив c
            c_ = np.zeros(x.shape)
            for i in range(Nx+1):
                c_[i] = c(x[i])
            c = c_
    
        q = c**2
        gamma2 = (tau/h)**2; tau2 = tau*tau    # Вспомогательные переменные
    
        # Обертка для заданных пользователем f, I, V, ul, ur
        if f is None or f == 0:
            f = (lambda x, t: 0) if version == 'scalar' else \ 
                lambda x, t: np.zeros(x.shape)
        if I is None or I == 0:
            I = (lambda x: 0) if version == 'scalar' else \ 
                lambda x: np.zeros(x.shape)
        if V is None or V == 0:
            V = (lambda x: 0) if version == 'scalar' else \ 
                lambda x: np.zeros(x.shape)
        if ul is not None:
            if isinstance(ul, (float,int)) and ul == 0:
                ul = lambda t: 0
        if ur is not None:
            if isinstance(ur, (float,int)) and ur == 0:
                ur = lambda t: 0
    
        # Делаем хэш всех входных данных
        import hashlib, inspect
        data = inspect.getsource(I) + '_' + inspect.getsource(V) + \ 
               '_' + inspect.getsource(f) + '_' + str(c) + '_' + \ 
               ('None' if ul is None else inspect.getsource(ul)) + \ 
               ('None' if ur is None else inspect.getsource(ur)) + \ 
               '_' + str(l) + str(tau) + '_' + str(gamma) + '_' + str(T) + \ 
               '_' + str(stability_safety_factor)
        hashed_input = hashlib.sha1(data).hexdigest()
        if os.path.isfile('.' + hashed_input + '_archive.npz'):
            # Расчет уже запущен
            return -1, hashed_input
    
        y   = np.zeros(Nx+1)   # Массив решения на новом слое
        y_1 = np.zeros(Nx+1)   # Решение на слое n
        y_2 = np.zeros(Nx+1)   # Решение на слое n-1
    
        import time;  t0 = time.clock()  # Измерение процессорного времени
    
        Ix = range(0, Nx+1)
        It = range(0, Nt+1)
    
        # Задаем начальные условия в y_1
        for i in range(0,Nx+1):
            y_1[i] = I(x[i])
    
        if user_action is not None:
            user_action(y_1, x, t, 0)
    
        # Специальная формула для первого слоя
        for i in Ix[1:-1]:
            y[i] = y_1[i] + tau*V(x[i]) + \ 
            0.5*gamma2*(0.5*(q[i] + q[i+1])*(y_1[i+1] - y_1[i]) - \ 
                    0.5*(q[i] + q[i-1])*(y_1[i] - y_1[i-1])) + \ 
            0.5*tau2*f(x[i], t[0])
    
        i = Ix[0]
        if ul is None:
            # Установка граничных условий du/dn = 0
            # x=0: i-1 -> i+1 так как y[i-1]=y[i+1]
            # x=l: i+1 -> i-1 так как y[i+1]=y[i-1])
            ip1 = i+1
            im1 = ip1  # i-1 -> i+1
            y[i] = y_1[i] + tau*V(x[i]) + \ 
                   0.5*gamma2*(0.5*(q[i] + q[ip1])*(y_1[ip1] - y_1[i])  - \ 
                           0.5*(q[i] + q[im1])*(y_1[i] - y_1[im1])) + \ 
            0.5*tau2*f(x[i], t[0])
        else:
            y[i] = ul(tau)
    
        i = Ix[-1]
        if ur is None:
            im1 = i-1
            ip1 = im1  # i+1 -> i-1
            y[i] = y_1[i] + tau*V(x[i]) + \ 
                   0.5*gamma2*(0.5*(q[i] + q[ip1])*(y_1[ip1] - y_1[i])  - \ 
                           0.5*(q[i] + q[im1])*(y_1[i] - y_1[im1])) + \ 
            0.5*tau2*f(x[i], t[0])
        else:
            y[i] = ur(tau)
    
        if user_action is not None:
            user_action(y, x, t, 1)
    
        # Обновляем данные для следущего слоя
        #y_2[:] = y_1;  y_1[:] = y  # безопасно, но медленнее
        y_2, y_1, y = y_1, y, y_2
    
        for n in It[1:-1]:
            # Расчет во внутренних узлах
            if version == 'scalar':
                for i in Ix[1:-1]:
                    y[i] = - y_2[i] + 2*y_1[i] + \ 
                        gamma2*(0.5*(q[i] + q[i+1])*(y_1[i+1] - y_1[i])  - \ 
                            0.5*(q[i] + q[i-1])*(y_1[i] - y_1[i-1])) + \ 
                    tau2*f(x[i], t[n])
    
            elif version == 'vectorized':
                y[1:-1] = - y_2[1:-1] + 2*y_1[1:-1] + \ 
                gamma2*(0.5*(q[1:-1] + q[2:])*(y_1[2:] - y_1[1:-1]) -
                    0.5*(q[1:-1] + q[:-2])*(y_1[1:-1] - y_1[:-2])) + \ 
                tau2*f(x[1:-1], t[n])
            else:
                raise ValueError('version=%s' % version)
    
            # Добавляем граничные условия
            i = Ix[0]
            if ul is None:
                # Устанавливаем граничные условия
                # x=0: i-1 -> i+1 так как y[i-1]=y[i+1] при du/dn=0
                # x=l: i+1 -> i-1 так как y[i+1]=y[i-1] при du/dn=0
                ip1 = i+1
                im1 = ip1
                y[i] = - y_2[i] + 2*y_1[i] + \ 
                       gamma2*(0.5*(q[i] + q[ip1])*(y_1[ip1] - y_1[i])  - \ 
                           0.5*(q[i] + q[im1])*(y_1[i] - y_1[im1])) + \ 
                tau2*f(x[i], t[n])
            else:
                y[i] = ul(t[n+1])
    
            i = Ix[-1]
            if ur is None:
                im1 = i-1
                ip1 = im1
                y[i] = - y_2[i] + 2*y_1[i] + \ 
                       gamma2*(0.5*(q[i] + q[ip1])*(y_1[ip1] - y_1[i])  - \ 
                           0.5*(q[i] + q[im1])*(y_1[i] - y_1[im1])) + \ 
                tau2*f(x[i], t[n])
            else:
                y[i] = ur(t[n+1])
    
            if user_action is not None:
                if user_action(y, x, t, n+1):
                    break
    
            # Обновляем данные для следующего слоя
            #y_2[:] = y_1;  y_1[:] = y
            y_2, y_1, y = y_1, y, y_2
    
        y = y_1
        cpu_time = t0 - time.clock()
        return cpu_time, hashed_input

.. _fdm-for-wave:gen_solver:solver_dissect:

Разбор          (1)
~~~~~~~~~~~~~~~~~~~

Реализация основного алгоритма аналогично рассмотренным выше. Поэтому
остановимся только на участке кода, связанного с переменной
``hashed_input``, используемой для задания имени итогового архивного
файла со всеми решениями. Переменная ``hashed_input`` отражает все
значения важных параметров задачи так, что имя файла будет
уникальным. Строка ``hashed_input`` генерируется с использованием
модулей ``hashlib`` и ``inspect`` на основе входных параметров функции
``solver``:

.. code-block:: python

    # Делаем хэш всех входных данных
    import hashlib, inspect
    data = inspect.getsource(I) + '_' + inspect.getsource(V) + \ 
           '_' + inspect.getsource(f) + '_' + str(c) + '_' + \ 
           ('None' if ul is None else inspect.getsource(ul)) + \ 
           ('None' if ur is None else inspect.getsource(ur)) + \ 
           '_' + str(l) + str(tau) + '_' + str(gamma) + '_' + str(T) + \ 
           '_' + str(stability_safety_factor)
    hashed_input = hashlib.sha1(data).hexdigest()

Для получения исходного кода функции ``f`` в качестве строки
используется ``inspect.getsource(f)``. Все входные данные, функции и
переменные объединяются в строку ``data``, затем функция ``hashlib.sha1``
создает уникальное более короткую строку фиксированной длины (40
символов) из строки ``data``, которую можно использовать в качестве
имени файла архива.


.. warning::
    Обратите внимание, что такое построение строки ``data`` не совсем
    подходящее: если, например, ``I`` --- это формула с параметрами, и
    параметры изменяются, исходный код остается тем же самым и
    соответственно хэш-строка остается неизменной. Поэтому данная
    реализация должна использоваться аккуратно!




Далее переменная ``hashed_input`` используется для избегания перезапуска
ранее выполнявшегося эксперимента. Если архивный файл с именем
основанным на ``hashed_input`` уже существует, то расчет с текущим
набором параметров уже был выполнен ранее и можно пропустить
выполнение повторной работы. функция ``solver`` возвращает процессорное
время ``cpu`` и ``hashed_input``, при этом отрицательное значение ``cpu``
означает, что расчет не был запущен. В этом случае мы не должны
запускать метод ``close_file`` объекта класса ``PlotAndStoreSolution``
(см. раздел :ref:`fdm-for-wave:gen_solver:user_action`). Типичное
использование переменных ``hashed_input`` и ``cpu`` выглядит следующим
образом:

.. code-block:: python

    action = PlotAndStoreSolution(...)
    tau = (l/Nx)/gamma  # выбор ограничения устойчивости по заданному Nx
    cpu, hashed_input = solver(
    	I=lambda x: 0 if abs(x-l/2.0) > 0.1 else 1,
    	V=0, f=0, c=1, ul=lambda t: 0, ur=None, l=l,
    	tau=tau, gamma=gamma, T=T,
    	user_action=action, version='vectorized',
    	stability_safety_factor=1)
    action.make_movie_file()
    if cpu > 0:  
    	action.close_file(hashed_input)

.. _fdm-for-wave:gen_solver:verif:

Верификация          (2)
------------------------

Точные решения численных уравнений всегда привлекательны для целей
тестирования, так как программное обеспечение должно воспроизводить такие
решения с машинной точностью. Для условий Дирихле мы можем построить
функцию линейную по :math:`t` и квадратичную по :math:`x`, которая является точным
решением схемы, в то время как для условий Неймана остается только
постоянное решение.

Более общий метод верификации --- проверка скорости сходимости (см.,
например, раздел :ref:`fdm-for-wave:verif:manufact`)

.. _fdm-for-wave:gen_solver:save_arrays:

Сохранение больших архивов в файлы с использованием ``savez``
-------------------------------------------------------------

При выполнении моделирования в качестве результата получаются большие
массивы, содержащие решение в узлах, и мы должны сохранять их на
диск. В Python доступно несколько методов. Мы рекомендуем использовать
специализированные решения для больших массивов, а не стандартные
инструменты хранения файлов, такие как ``pickle`` (``cPickle`` для
ускорения в Python версии 2) и ``shelve``.

Сохранение индивидуальных массивов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Функция ``numpy.savez`` может сохранить набор массивов в именованный 
файл в zip-архиве. Связанная с ней функция ``numpy.load`` может
использоваться для чтения файла. В основном, мы вызываем
``numpy.savez(filename, **kwargs)``, где ``kwargs`` --- словарь,
содержащий имя массива в качестве ключа и соответствующий
объект-массив в качестве значения. Очень часто решению в момент
времени дается естественное имя, где имя переменной и счетчик
временного слоя объединяются, например, ``u11`` или ``v39``. Предположим, что ``n``
--- счетчик временного слоя и у нас есть два массива с решениями ``u`` и
``v``, которые мы хотим сохранить в zip-архив. Соответствующий код
представлен ниже

.. code-block:: python

    import numpy as np
    u_name = 'u%04d' % n	# имя массива
    v_name = 'v%04d' % n	# имя массива
    kwargs = {u_name: u, v_name: v}	# аргументы ключевых слов для savez
    fname = '.mydata%04.dat' % n
    np.savez(fname, **kwargs)
    if n == 0:		# сохраняем x один раз
       np.savez('.mydata_x.dat', x=x)

Так как имя массива должно быть передано в качестве аргумента
ключевого слова для ``savez``, и имя генерируется как показано в
примере, становится сложно сделать вызов, но с помощью словаря
``kwargs`` и ``**kwargs``, который отправляет каждую пару ключ-значение в
качетсве отдельных аргументов ключевого слова,  задача выполняется.

Слияние zip-архивов
~~~~~~~~~~~~~~~~~~~

Каждый отдельный вызов функции ``numpy.savez`` создает новый файл
(zip-архив) с расширением ``.npz`` (добавляется автоматически). Очень
удобно собрать все результаты в одном архиве. Это можно сделать
слиянием индивидуальных архивов в один zip-архив:

.. code-block:: python

    def merge_zip_archives(individual_archives, archive_name):
    	"""
    	Слияние индивидуальных zip-архивов, сделанных с помощью
    	numpy.savez, в один архив с именем archive_name.
    	Отдельные архивы могут быть заданы как список имен.
    	В результате выполнения этой функции все отдельные 
    	архивы удаляются и создается один новый архив.
    	"""
    	import zipfile
    	archive = zipfile.ZipFile(
    		archive_name, 'w', zipfile.ZIP_DEFLATED,
    		allowZip64=True)
    	if isinstance(individual_archives, (list,tuple)):
    		filenames = individual_archives
    	elif isinstance(individual_archives, str):
    		filenames = glob.glob(individual_archives)
    
    	# Открываем каждый архив и пишем его в общий архив
    	for filename in filenames:
    		f = zipfile.ZipFile(filename,  'r',
    		                    zipfile.ZIP_DEFLATED)
    		for name in f.namelist():
    			data = f.open(name, 'r')
    			# Сохраняем под именем без .npy
    			archive.writestr(name[:-4], data.read())
    		f.close()
    		os.remove(filename)
    	archive.close()

Этот подход используется в разделе
:ref:`fdm-for-wave:gen_solver:user_action` в методе ``close_file``.

Чтение массивов из zip-архива
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Архивы, созданные с помощью ``savez`` или объединенный массив, описанный
выше, с именем вида ``myarchive.npz`` могут быть загружены с помощью
функции ``numpy.load``: 

.. code-block:: python

    import numpy as np
    array_names = np.load(`myarchive.npz`)
    for array_name in array_names:
        # array_names[array_name] is the array itself
        # e.g. plot(array_names['t'], array_names[array_name])

.. _fdm-for-wave:gen_solver:user_action:

Реализация функции действий полозователя в виде класса
------------------------------------------------------

Полезная особенность сценария
`wave1d_dn_vc.py <src-fdm-for-wave/wave1d_dn_vc.py>`__ --- это
реализация функции действия пользователя в виде класса. Эта часть
сценария может потребовать некоторых пояснений.

.. _fdm-for-wave:gen_solver:code:

Код          (2)
~~~~~~~~~~~~~~~~

Класс для построения графиков, очистки файлов, создания анимированных
графиков, которые выполнялись в функции ``wave1d_1.viz``, можно
реализовать следующим образом:

.. code-block:: python

    class PlotAndStoreSolution:
    	"""
    	Класс для функиции user_action в solver.
    	Только визуализация решения.
    	"""
    	def __init__(
    			self,
    			casename='tmp',    # Префикс в именах файлов
    			umin=-1, umax=1,   # Задаются границы по оси y
    			pause_between_frames=None,  # Скорость видео
    			backend='matplotlib',       # или 'gnuplot' или None
    			screen_movie=True, # Показывать видео на экране?
    			title='',          # Дополнительное сообщение в title
    			skip_frame=1,      # Пропуск каждого skip_frame кадра
    			filename=None):    # Имя файла с решением
    		self.casename = casename
    		self.yaxis = [umin, umax]
    		self.pause = pause_between_frames
    		self.backend = backend
    		if backend is None:
    			# Использовать matplotlib
    			import matplotlib.pyplot as plt
    		elif backend in ('matplotlib', 'gnuplot'):
    			module = 'scitools.easyviz.' + backend + '_'
    			exec('import %s as plt' % module)
    		self.plt = plt
    		self.screen_movie = screen_movie
    		self.title = title
    		self.skip_frame = skip_frame
    		self.filename = filename
    		if filename is not None:
    			# Сохранение временной сетки, когда y записывается в файл
    			self.t = []
    			filenames = glob.glob('.' + self.filename + '*.dat.npz')
    			for filename in filenames:
    				os.remove(filename)
    
    		# Очистка старых кадров
    		for filename in glob.glob('frame_*.png'):
    			os.remove(filename)
    
    	def __call__(self, u, x, t, n):
    		"""
    		Функция обратного вызова user_action, вызываемая солвером:
    		сохранение решения, построение графиков на экране и
    		и сохранение их в файл.
    		"""
    		# Сохраняем решение u в файл, используя numpy.savez
    		if self.filename is not None:
    			name = 'u%04d' % n  # имя массива
    			kwargs = {name: u}
    			fname = '.' + self.filename + '_' + name + '.dat'
    			np.savez(fname, **kwargs)
    			self.t.append(t[n])  # сохранение соответствующего временного знаяения
    			if n == 0:           # сохранение массива x один раз
    				np.savez('.' + self.filename + '_x.dat', x=x)
    
    		# Анимация
    		if n % self.skip_frame != 0:
    			return
    		title = 't=%.3f' % t[n]
    		if self.title:
    			title = self.title + ' ' + title
    		if self.backend is None:
    			# анимация matplotlib 
    			if n == 0:
    				self.plt.ion()
    				self.lines = self.plt.plot(x, u, 'r-')
    				self.plt.axis([x[0], x[-1],
    				               self.yaxis[0], self.yaxis[1]])
    				self.plt.xlabel('x')
    				self.plt.ylabel('u')
    				self.plt.title(title)
    				self.plt.legend(['t=%.3f' % t[n]])
    			else:
    				# Обновляем решение
    				self.lines[0].set_ydata(u)
    				self.plt.legend(['t=%.3f' % t[n]])
    				self.plt.draw()
    		else:
    			# анимация scitools.easyviz 
    			self.plt.plot(x, u, 'r-',
    			              xlabel='x', ylabel='u',
    			              axis=[x[0], x[-1],
    			                    self.yaxis[0], self.yaxis[1]],
    			              title=title,
    			              show=self.screen_movie)
    		# пауза
    		if t[n] == 0:
    			time.sleep(2)  # показываем начальное решение 2 с
    		else:
    			if self.pause is None:
    				pause = 0.2 if u.size < 100 else 0
    			time.sleep(pause)
    
    		self.plt.savefig('frame_%04d.png' % (n))
    
    	def make_movie_file(self):
    		"""
    		Создается подкаталог на основе casename, перемещаем все файлы
    		с кадрами в этот каталог и создаем файл index.html для показа
    		видео в браузере (как последовательности PNG файлов).
    		"""
    		directory = self.casename
    		if os.path.isdir(directory):
    			shutil.rmtree(directory)   # rm -rf directory
    		os.mkdir(directory)            # mkdir directory
    		# mv frame_*.png directory
    		for filename in glob.glob('frame_*.png'):
    			os.rename(filename, os.path.join(directory, filename))
    		os.chdir(directory)        # cd directory
    		fps = 4 # frames per second
    		if self.backend is not None:
    			from scitools.std import movie
    			movie('frame_*.png', encoder='html',
    			      output_file='index.html', fps=fps)
    
    		# Создаем другие видео форматы: Flash, Webm, Ogg, MP4
    		codec2ext = dict(flv='flv', libx264='mp4', libvpx='webm',
    		                 libtheora='ogg')
    		filespec = 'frame_%04d.png'
    		movie_program = 'avconv' # или 'ffmpeg' 
    		for codec in codec2ext:
    			ext = codec2ext[codec]
    			cmd = '%(movie_program)s -r %(fps)d -i %(filespec)s '\ 
    			      '-vcodec %(codec)s movie.%(ext)s' % vars()
    			os.system(cmd)
    		os.chdir(os.pardir)  # возвращаемся в родительский каталог
    
    	def close_file(self, hashed_input):
    		"""
    		Сливаем все файлы в один архив.
    		hashed_input --- строка, отражающая входные данные
    		для моделирования (создана функцией solver).
    		"""
    		if self.filename is not None:
    			np.savez('.' + self.filename + '_t.dat',
    			         t=np.array(self.t, dtype=float))
    
    			archive_name = '.' + hashed_input + '_archive.npz'
    			filenames = glob.glob('.' + self.filename + '*.dat.npz')
    			merge_zip_archives(filenames, archive_name)
    		print 'Archive name:', archive_name
    		# data = numpy.load(archive); data.files holds names
    		# data[name] extract the array

.. _fdm-for-wave:gen_solver:dissect:

Разбор          (2)
~~~~~~~~~~~~~~~~~~~

Представленный выше класс поддерживает построение графиков с помощью
Matplotlib (``backend=None``) или SciTools (``backend=matplotlib`` или
``backend=gnuplot``).

Конструктор показывает как можно гибко импортировать графический
модуль как ``scitools.easyviz.gnuplot_`` или
``scitools.easyviz.matplotlib_`` (символ подчеркивания в конце
обязателен). С помощью параметра ``screen_movie`` мы можем подавлять
вывод графиков на экран. В качестве альтернативы, для медленных
анимированных графиков, связанных с мелкой расчетной сеткой, мы можем
задать ``skip_frame=10``, устанавливая показ каждого десятого кадра.

Метод ``__call__`` позволяет объектам класса ``PlotAndStoreSolution``
вести себя как функции, так что мы можем передавать объект, например
``p``, в качестве аргумента ``user_action`` в функцию ``solver``, и любой
вызов ``user_action`` будет вызывать ``p.__call__``. Метод ``__call__``
строит график решения на экране, сохраняет график в файл, а также
сохраняет решение в файл для дальнейшего использования.

.. _fdm-for-wave:gen_solver:pulse:

Распространение импульса в двух средах
--------------------------------------

Функция ``pulse`` в `wave1d_dn_vc.py <src-fdm-for-wave/wave1d_dn_vc.py>`__
демонстрирует движение волны в разнородных средах с переменным
:math:`c`. Можно задать интервал, на котором скорость распространения волны
уменьшается пропорционально множителю ``slowness_factor`` (или
увеличивается если задать этот множитель меньшим единицы).

Четыре типа начального распределения реализованы:

1. прямоугольный импульс (``plug``)

2. функция Гаусса (``gaussian``)

3. один период косинуса (``cosinehat``)

4. половина периода косинуса (``half-cosinehat``)

Эти начальные условия, имеющие форму пика, могут помещаться посередине
(``loc=center``) или на левом конце (``loc=left``) расчетной
области. Импульсы, расположенные посередине, распадаются на две части,
каждая с амплитудой, в два раза меньшей начальной, и движутся в
противоположных направлениях. Если импульс расположен на левом конце
(центр импульса в :math:`x=0`) и задано условие Неймана, генерируется только
волна бегущая вправо. Также возникает волна, движущаяся влево, но она
бежит от :math:`x=0` в отрицательной части оси :math:`x` и не видна на отрезке
:math:`[0, l]`. Функция ``pulse`` является удобным инструментом для вариации с
разными формами импульса и расположениями сред с разными скоростями
распространения волны. Ниже представлена реализация данной функции:

.. code-block:: python

    def pulse(gamma=1,            # максимальное число Куранта
              Nx=200,         # число узлов по пространству
              animate=True,
              version='vectorized',
              T=2,            # конечное время
              loc='left',     # размещение начального условия
              pulse_tp='gaussian',  # pulse/init.cond. 
              slowness_factor=2, # скорость распространения волны в правой среде
              medium=[0.7, 0.9], # отрезок правой области (среды)
              skip_frame=1,      
              sigma=0.05):
    	"""
    	Различные пико-образные начальные условия на [0,1].
    	Скорость распространения волны уменьшается в slowness_factor раз
    	венутри среды. Параметр loc может принимать значения 'center' или 'left',
    	в зависимости от того, где располагается пик начальных условий.
    	Параметр sigma определяет ширину импульса.
    	"""
    	# Используем безразмерные параметры: l=1 для длины области,
    	# c_0=1 для скорости распространения волны вне области.
    	l = 1.0
    	c_0 = 1.0
    	if loc == 'center':
    		xc = l/2
    	elif loc == 'left':
    		xc = 0
    
    	if pulse_tp in ('gaussian','Gaussian'):
    		def I(x):
    			return np.exp(-0.5*((x-xc)/sigma)**2)
    	elif pulse_tp == 'plug':
    		def I(x):
    			return 0 if abs(x-xc) > sigma else 1
    	elif pulse_tp == 'cosinehat':
    		def I(x):
    			# Один период косинуса
    			w = 2
    			a = w*sigma
    			return 0.5*(1 + np.cos(np.pi*(x-xc)/a)) \ 
    				if xc - a <= x <= xc + a else 0
    
    	elif pulse_tp == 'half-cosinehat':
    		def I(x):
    			# Половина периода косинуса
    			w = 4
    			a = w*sigma
    			return np.cos(np.pi*(x-xc)/a) \ 
    				if xc - 0.5*a <= x <= xc + 0.5*a else 0
    	else:
    		raise ValueError(u'Ошибочный_tp="%s"' % pulse_tp)
    
    	def c(x):
    		return c_0/slowness_factor \ 
    			if medium[0] <= x <= medium[1] else c_0
    
    	umin=-0.5; umax=1.5*I(xc)
    	casename = '%s_Nx%s_sf%s' % \ 
    	           (pulse_tp, Nx, slowness_factor)
    	action = PlotMediumAndSolution(
    		medium, casename=casename, umin=umin, umax=umax,
    		skip_frame=skip_frame, screen_movie=animate,
    		backend='matplotlib', filename='tmpdata')
    
    	# Выбор ограничения устойчивости при заданном Nx, худший случай c
    	# (меньший gamma будет использовать этот шаг tau, но меньшее Nx)
    	tau = (l/Nx)/c_0
    	cpu, hashed_input = solver(I=I, V=None, f=None, c=c, ul=None, ur=None,
    	                           l=l, tau=tau, gamma=gamma, T=T,
    	                           user_action=action, version=version,
    	                           stability_safety_factor=1)
    	action.make_movie_file()
    	action.close_file(hashed_input)

Используемый здесь класс ``PlotMediumAndSolution`` --- это подкласс
класса ``PlotAndStoreSolution``, где среда с уменьшенным коэффициентом
:math:`c`, заданная параметром ``medium``, отображается на графике.


.. admonition:: Комментарий по выбору параметров дискретизации

   Параметр :math:`N_x` в функции ``pulse`` не соответствует фактической
   пространственной сетке, соответствующей :math:`\gamma < 1`, так как функция
   ``solver`` принимает фиксированные значения :math:`\tau` и :math:`\gamma` и
   вычисляет :math:`h` соответствующим образом. Как видно, в функции ``pulse``
   заданное значение :math:`\tau` выбирается из условия :math:`\gamma=1`, поэтому,
   если :math:`\gamma < 1`, :math:`\gamma` остается таким же, а функция ``solver``
   оперирует большим значением :math:`h` и :math:`N_x` меньшим, чем заданным в
   ``pulse``. Причина этого в том, что мы хотим сохранять фиксированный шаг
   :math:`\tau` графические кадры в анимации синхронизированы по времени
   независимо от значения :math:`\gamma` (т.е. :math:`h` меняется, если меняется
   число Куранта).


 

Читателю предлагается "поиграть" с функцией ``pulse``:

.. code-block:: python

    >>> import wave1d_dn_vc as w
    >>> w.pulse(loc='left', pulse_tp='cosinehat', Nx=50, skip_frame=10)

Для того, чтобы легко остановить отображение графиков (например, с
помощью Ctrl-C) и начать новое вычисление, может быть проще запустить
предыдущие два выражения из командной строки:

.. code-block:: text

    Terminal> python -c 'import wave1d_dn_vc as w; w.pulse(loc='left', pulse_tp='cosinehat', Nx=50, skip_frame=10)'

.. Local Variables:

.. doconce-chapter-nickname: "fdm-for-wave"

.. doconce-section-nickname: "gen_solver"

.. End:

