.. !split

.. _fdm-for-wave:string_eq:

Разностная схема для одномерного волнового уравнения
====================================================

.. index:: Уравнение колебаний струны

.. index:: Волновое уравнение

.. index::
   single: Волновое уравнение; одномерное

Рассмотрим одномерную математическую модель распространения колебаний
на струне. Пусть струна в деформированном состоянии 
распространяется на интервале :math:`[0, l]` оси :math:`x` и
:math:`u(x,t)` --- перемещение по времени в направлении :math:`y`
точки, изначально лежащей на оси :math:`x`. Функция перемещения
:math:`u(x,t)` определяется следующей математической моделью:

.. _Eq:fdm-for-wave:string_eq:eq:string:

.. math::

    \tag{1}
    \frac{\partial^2 u}{\partial t^2} =
           c^2 \frac{\partial^2 u}{\partial x^2},
           \quad x \in (0, l), \quad t \in (0, T], 
        

.. _Eq:fdm-for-wave:string_eq:eq:init_u:

.. math::

    \tag{2}
    u(x,0) = I(x), \quad x \in [0, l],
        

.. _Eq:fdm-for-wave:string_eq:eq:init_vel:

.. math::

    \tag{3}
    \frac{\partial u(x,0)}{\partial t} = 0, \quad x \in [0, l],
        

.. _Eq:fdm-for-wave:string_eq:eq:bound_left:

.. math::

    \tag{4}
    u(0,t) = 0, \quad t \in (0, T],
        

.. _Eq:fdm-for-wave:string_eq:eq:bound_right:

.. math::

    \tag{5}
    u(l,t) = 0, \quad t \in (0, T].
        

Постоянная :math:`c` и функция :math:`I(x)` --- заданы.

Уравнение :ref:`(1) <Eq:fdm-for-wave:string_eq:eq:string>` известно как
*волновое уравнение* (*уравнение колебаний струны*). Так как это
уравнение в частных производных содержит вторую производную по
времени, необходимо задать два начальных условия. Условие
:ref:`(2) <Eq:fdm-for-wave:string_eq:eq:init_u>` начальную форму струны, 
а условие :ref:`(3) <Eq:fdm-for-wave:string_eq:eq:init_vel>` означает, что начальная скорость
струны равна нулю. Кроме того уравнение
:ref:`(1) <Eq:fdm-for-wave:string_eq:eq:string>` дополняется 
граничными условиями :ref:`(4) <Eq:fdm-for-wave:string_eq:eq:bound_left>` и 
:ref:`(5) <Eq:fdm-for-wave:string_eq:eq:bound_right>`. Эти два условия означают,
что струна закреплена на концах, т.е. перемещения равны нулю. 

Перейдем к построению конечно-разностной аппроксимации задачи
:ref:`(1) <Eq:fdm-for-wave:string_eq:eq:string>`--:ref:`(5) <Eq:fdm-for-wave:string_eq:eq:bound_right>`. 

.. index:: Сетка

.. _fdm-for-wave:string_eq:grid:

Расчетная сетка
---------------

Для построения разностной схемы надо прежде всего ввести сетку в
области изменения независимых переменных и задать шаблон,
т.е. множество точек сетки, участвующих в аппроксимации
дифференциального выражения. Введем равномерную сетку по переменному
:math:`x` с шагом :math:`h`

.. math::
        
           \omega_h = \left\{ x_i = ih, \ i = 0, 1, \ldots, N, \ hN = l
           \right\},
        

и сетку по переменной :math:`t` с шагом :math:`\tau`

.. math::
        
           \omega_{\tau} = \left\{ t_n = n\tau, \ n = 0, 1, \ldots, K, \ K\tau
           = T \right\}.
        

Точки :math:`(x_i,t_n)`, :math:`i = 0, 1, \ldots, N`,
:math:`n = 0, 1, \ldots, K`, образуют узлы пространственно-временной
сетки :math:`\omega_{h\tau} = \omega_h \times \omega_{\tau}`
(см. рис. :ref:`fdm-for-wave:string_eq:fig:1`)

.. _fdm-for-wave:string_eq:fig:1:

.. figure:: wave-grid.png
   :width: 400

   Пространственно-временная сетка :math:`\omega_{h\tau}`

.. index:: Узлы

.. index::
   single: Узлы;  граничные

.. index::
   single: Узлы;  внутренние

Узлы :math:`(x_i,t_n)`, принадлежащие отрезкам
:math:`I_0=\{0 \leq x \leq l,\ t = 0\}`, :math:`I_l=\{x = 0, \ 0 \leq t \leq T\}`,
:math:`I_r=\{x = l, \ 0 \leq t \leq T\}` называются *граничными узлами*
сетки :math:`\omega_{h\tau}`, а остальные узлы --- *внутренними*. На
рис.  :ref:`fdm-for-wave:string_eq:fig:1` граничные узлы 
обозначены крестиками, а внутренние кружочками.

*Слоем* называется множество всех узлов сетки :math:`\omega_h\tau`,
имеющих одну и ту же временную координату. Так, :math:`n`-м слоем
называется множество узлов

.. math::
        
           (x_0, t_n), (x_1, t_n), \ldots, (x_N, t_n).	
        

Очевидно, минимальный шаблон, на котором можно аппроксимировать
уравнение :ref:`(1) <Eq:fdm-for-wave:string_eq:eq:string>`, это пятиточечный
шаблон, изображенный на рис. :ref:`fdm-for-wave:string_eq:fig:2`. Таким
образом, здесь требуется использовать три временных слоя: :math:`n-1`, :math:`n`,
:math:`n+1`. Такие схемы называются *трехслойными*. Их применение
предполагает, что при нахождении значений :math:`y_i^{n+1}` на верхнем
слое значения на предыдущих слоях :math:`y_i^{n}`, :math:`y_i^{n-1}`,
:math:`i = 0, 1, \ldots, N` хранятся в памяти.

.. _fdm-for-wave:string_eq:fig:2:

.. figure:: wave-templ.png
   :width: 400

   *Минимальный шаблон трехслойной разностной схемы*

.. _fdm-for-wave:string_eq:fdm:

Разностная схема
----------------

.. index::
   single: Разностная схема;  трехслойная

Простейшей разностной аппроксимацией уравнения :ref:`(1) <Eq:fdm-for-wave:string_eq:eq:string>` и
граникных условий :ref:`(4) <Eq:fdm-for-wave:string_eq:eq:bound_left>` и
:ref:`(5) <Eq:fdm-for-wave:string_eq:eq:bound_right>` является следующая
система уравнений: 

.. _Eq:fdm-for-wave:string_eq:eq:fds:

.. math::

    \tag{6}
    \frac{y_i^{n+1} - 2 y_i^{n} + y_i^{n-1}}{\tau^2} =
           \frac{y_{i+1}^n - 2 y_{i}^n + y_{i-1}^n}{h^2}, 
        

.. math::
          
           i = 1, 2,
           \ldots, N-1, \ n = 1, 2, \ldots, K, \nonumber
        

.. _Eq:fdm-for-wave:string_eq:eq:fds_bound:

.. math::

    \tag{7}
    y_0^{n+1} = y_N^{n+1} = 0, \quad n = 0, 1, \ldots, K-1.
        

Разностное уравнение :ref:`(1) <Eq:fdm-for-wave:string_eq:eq:string>` имеет второй порядок
погрешности аппроксимации по :math:`\tau` и по :math:`h`. Решение
:math:`y_i^{n+1}` выражается явным образом через значения на
предыдущих слоях:

.. _Eq:fdm-for-wave:string_eq:eq:fds_rec:

.. math::

    \tag{8}
    y_i^{n+1} = 2 y_i^n - y_i^{n-1} + \gamma^2 (y_{i+1}^n - 2y_{i}^n +
           y_{i-1}^n), 
        

.. math::
          
           i = 1, 2, \ldots, N-1, \ n = 1, 2, \ldots, K-1. \nonumber
        

.. index:: Число Куранта

Здесь мы ввели параметр

.. math::
        
           \gamma = c\frac{\tau}{h},
        

который называют *числом Куранта*.

Для начала счета по :ref:`(8) <Eq:fdm-for-wave:string_eq:eq:fds_rec>` должны быть заданы значения
:math:`y_i^0, y_i^1`, :math:`i = 0, 1, \ldots, N`. Из первого
начального условия :ref:`(2) <Eq:fdm-for-wave:string_eq:eq:init_u>` сразу получаем

.. _Eq:fdm-for-wave:string_eq:eq:y0:

.. math::

    \tag{9}
    y_i^0 = I(x_i), \quad i = 0, 1, \ldots, N.
        

.. _fdm-for-wave:string_eq:fds_init:

Аппроксимация второго начального условия
----------------------------------------

Простейшая замена второго начального условия :ref:`(3) <Eq:fdm-for-wave:string_eq:eq:init_vel>`
уравнением :math:`(y_i^1 - y_i^0)/\tau = 0` имеет лишь первый порядок
аппроксимации по :math:`\tau`. Поскольку уравнение :ref:`(6) <Eq:fdm-for-wave:string_eq:eq:fds>`
аппроксимирует уравнение :ref:`(1) <Eq:fdm-for-wave:string_eq:eq:string>` со
вторым порядком, желательно, чтобы и разностное начальное условие
также имело второй порядок аппроксимации. Построим такую
аппроксимацию. Уравнение 

.. _Eq:fdm-for-wave:string_eq:eq:fds_init:

.. math::

    \tag{10}
    \frac{y_i^1 - y_i^{-1}}{2\tau} = 0,
        

аппроксимирует уравнение :math:`\frac{\partial u}{\partial t} = 0` со
вторым порядком. Чтобы найти значения :math:`y_i^{-1}` запишем
уравнение :ref:`(6) <Eq:fdm-for-wave:string_eq:eq:fds>` при :math:`n = 0`:

.. math::
        
        	\frac{y_i^1 - 2 y_i^0 + y_i^{-1}}{\tau^2} = y_{\bar{x}x,i}^0,
        

Из :ref:`(10) <Eq:fdm-for-wave:string_eq:eq:fds_init>`  имеем :math:`y^{-1} = y^{1}`. Отсюда получаем

.. _Eq:fdm-for-wave:string_eq:eq:y1:

.. math::

    \tag{11}
    y_i^1 = y_i^0 + \frac{\gamma^2}{2} \left( y_{i+1}^0 - 2 y_{i}^0 +
           y_{i-1}^0 \right).
        

Совокупность уравнений :ref:`(6) <Eq:fdm-for-wave:string_eq:eq:fds>`,
:ref:`(7) <Eq:fdm-for-wave:string_eq:eq:fds_bound>`,
:ref:`(9) <Eq:fdm-for-wave:string_eq:eq:y0>` и 
:ref:`(10) <Eq:fdm-for-wave:string_eq:eq:fds_init>` составляет разностную
схему, аппроксимирующую исходную задачу
:ref:`(1) <Eq:fdm-for-wave:string_eq:eq:string>`--:ref:`(5) <Eq:fdm-for-wave:string_eq:eq:bound_right>`. 

.. _fdm-for-wave:string_eq:alg:

Вычислительный алгоритм
-----------------------

Теперь мы можем сформулировать вычислительный алгоритм:

1. Вычисляем :math:`y_i^0`, используя :ref:`(9) <Eq:fdm-for-wave:string_eq:eq:y0>`.

2. Вычисляем :math:`y_i^1`, используя :ref:`(11) <Eq:fdm-for-wave:string_eq:eq:y1>` и задаем граничные условия :ref:`(7) <Eq:fdm-for-wave:string_eq:eq:fds_bound>` при :math:`n=0`.

3. Для всех временных слоев :math:`n = 1, 2, \ldots, K-1`

  a. находим :math:`y_i^{n+1}`, используя :ref:`(8) <Eq:fdm-for-wave:string_eq:eq:fds_rec>`.

  b. задаем граничные условия :ref:`(7) <Eq:fdm-for-wave:string_eq:eq:fds_bound>`.

.. _fdm-for-wave:string_eq:sketch:

Эскиз программной реализации
----------------------------

При реализации представленного алгоритма на Python будем использовать
массивы ``y[i]`` для хранения значений :math:`y_i^{n+1}`, ``y_1[i]`` для
хранения значений :math:`y_i^{n}` и ``y_2[i]`` для хранения
:math:`y_i^{n-1}`. Можно считать, что используется следующее
соглашение о названии переменных: ``y`` используется для вычисляемого
пространственного распределения (сеточной функции) на новом временном
шаге, ``y_1`` --- решение на временном шаге, отстоящем на один
временной слой назад, ``y_2`` --- на два временных слоя назад и т.д.

Алгоритм использует только три временных слоя, таким образом, нам
достаточно иметь только три массива для :math:`y_i^{n+1}, y_i^n` и
:math:`y_i^{n-1}`, :math:`i = 0, 1, \ldots, N`. Хранение всего
решения в двумерном массиве размерности :math:`(N+1) \times (K+1)`
возможно в простейшем одномерном случае уравнений в частных
производных, но не для двумерных и трехмерных задач. Таким образом,
во всех программах для решения уравнений в частных производных мы будем 
хранить в памяти минимально возможное число временных слоев.

Следующий фрагмент кода реализует вычислительный алгоритм

.. code-block:: python

    # -*- coding: utf-8 -*-
    
    # --- Start snippet 1 ---
    # Заданные сетки как массивы x и t
    dx = x[1] - x[0]
    dt = t[1] - t[0]
    C = c*dt/dx  # Число Куранта
    K = len(t) - 1
    N = len(x) - 1
    C2 = C**2
    
    # Задаем начальное условие
    for i in range(N+1) :
    	y_1[i] = I(x[i])
    
    # Используем специальную формулу для расчета на первом
    # временном шаге с учетом du/dt = 0
    for i in range(N):
    	y[i] = y_1[i] - 0.5*C2(y_1[i+1] - 2*y_1[i] + y_1[i-1])
    y[0] = 0; y[N] = 0 # Применяем граничные условия
    
    # Изменяем переменные перед переходом на следующий
    # временной слой
    y_2[:], y_1[:] = y_1, y
    
    for n in range(K) :
    	# Пересчитываем значения во внутренних узлах сетки на слое n+1
        for i in range(1, N) :
    	    y[i] = 2*y_1[i] - y_2[i] - C2*(y_1[i+1] - 2*y_1[i] + y_1[i-1])
        # Задаем граничные условия
        y[0] = 0; y[N] = 0
        # Изменяем переменные перед переходом на следующий
        # временной слой
        y_2[:], y_1[:] = y_1, y
    # --- End snippet 1 ---
    
    # --- Start snippet 2 ---
    i = 0
    ip1 = i+1
    im1 = ip1  # i-1 -> i+1
    y[i] = y_1[i] + gamma2*(y_1[im1] - 2*y[i] + y_1[ip1])
    
    i = N
    im1 = i-1
    ip1 = im1  # i+1 -> i-1
    y[i] = y_1[i] + gamma2*(y_1[im1] - 2*y[i] + y_1[ip1])
    # --- End snippet 2 ---
    
    # --- Start snippet 3 ---
    for i in range(0, N+1):
    	ip1 = i+1 if i < N+1 else i-1
    	im1 = i-1 if i > 0 else i+1
    	y[i] = y_1[i] + gamma2*(y_1[im1] - 2*y[i] + y_1[ip1])
    # --- End snippet 3 ---
    
    # --- Start snippet 4 ---
    # Начальные условия
    for i in Ix[1:-1]:
    	y[i] = y_1[i] - 0.5*gamma2*(y_1[i+1] - 2*y_1[i] + y_1[i-1])
    
    # Цикл по времени
    for i in It[1:-1]:
    	# Вычисление значений во внутренних узлах
    	for i in Ix[1:-1]:
    		y[i] = 2*y_2[i] - y_1[i] + \
    		       gamma2*(y_1[i+1] - 2*y_1[i] + y_1[i-1])
    	# Вычисление граничных условий
    	i = Ix[0]; y[i] = 0
    	i = Ix[-1]; y[i] = 0
    # --- End snippet 4 ---

.. Local Variables:

.. doconce-chapter-nickname: "fdm-for-wave"

.. doconce-section-nickname: "string_eq"

.. _fdm-for-wave:verif:

Верификация программной реализации
==================================

Прежде чем реализовывать алгоритм, удобно добавить в уравнение
:ref:`(1) <Eq:fdm-for-wave:string_eq:eq:string>` слагаемое, описывающее источник
(правую часть), что даст свободу в выборе тестовых задач для
верификации алгоритма. 

.. index::
   single: Волновое уравнение;  неоднородное

.. _fdm-for-wave:verif:string_unhom:

Неоднородное уравнение
----------------------

Рассмотрим следующую смешанную задачу для неоднородного волнового
уравнения:

.. _Eq:fdm-for-wave:verif:eq:string_unhom:

.. math::

    \tag{12}
    \frac{\partial^2 u}{\partial t^2} = c^2 \frac{\partial^2
           u}{\partial x^2} + f(x, t), \quad x \in(0, l), \quad t \in (0,
           T],
        

.. _Eq:fdm-for-wave:verif:eq:init_u_unhom:

.. math::

    \tag{13}
    u(x,0) = I(x), \quad x \in [0, l],
        

.. _Eq:fdm-for-wave:verif:eq:init_vel_unhom:

.. math::

    \tag{14}
    \frac{\partial u(x,0)}{\partial t} = V(x), \quad x \in [0, l],
        

.. _Eq:fdm-for-wave:verif:eq:bound_left_unhom:

.. math::

    \tag{15}
    u(0, t) = 0, \quad t \in (0, T],
        

.. _Eq:fdm-for-wave:verif:eq:bound_right_unhom:

.. math::

    \tag{16}
    u(l, t) = 0, \quad t \in (0, T].
        

Аппроксимируя задачу
:ref:`(12) <Eq:fdm-for-wave:verif:eq:string_unhom>`--:ref:`(16) <Eq:fdm-for-wave:verif:eq:bound_right_unhom>`
(аналогично случаю однородного уравнения) разностной схемой второго
порядка аппроксимации на сетке :math:`\omega_{h\tau}`, получим рекуррентное соотношение

.. _Eq:fdm-for-wave:verif:eq:fdm_rec:

.. math::

    \tag{17}
    y_i^{n+1} = 2 y_i^n - y_i^{n-1} + \gamma^2 (y_{i+1}^n - 2y_{i}^n +
           y_{i-1}^n) + \tau^2 f_i^n, 
        

.. math::
          
           i = 1, 2, \ldots, N-1, \ n = 1, 2, \ldots, K-1. \nonumber
        

Кроме того аппроксимируя начальное условие
:ref:`(14) <Eq:fdm-for-wave:verif:eq:init_vel_unhom>` со вторым порядком

.. math::
        
           \frac{y_i^1 - y_i^{-1}}{2\tau} = V(x_i) \Rightarrow y_i^{-1} =
           y_i^1 - 2\tau V(x_i),
        

для нахождения значений приближенного решения на первом временном слое
получим

.. _Eq:fdm-for-wave:verif:eq:y1_unhom:

.. math::

    \tag{18}
    y_i^1 = y_i^0 + \tau V(x_i) + \frac{\gamma^2}{2} \left( y_{i+1}^0 - 2 y_{i}^0 +
           y_{i-1}^0 \right) + \frac{\tau^2}{2} f_i^0.
        

.. _fdm-for-wave:verif:analtic:

Использование аналитического решения
------------------------------------

Многие волновые задачи описывают синусоидальные по времени и
пространству. Например, исходная задача
:ref:`(1) <Eq:fdm-for-wave:string_eq:eq:string>`--:ref:`(5) <Eq:fdm-for-wave:string_eq:eq:bound_right>`
допускает точное решение 

.. _Eq:fdm-for-wave:verif:eq:exact_sol:

.. math::

    \tag{19}
    u_e(x,t) = A \sin \frac{\pi x}{l} \cos \frac{\pi c t}{l}
        

Это решение удовлетворяет однородному волновому уравнению, однородным
граничным условиям, а также начальным условиям
:math:`I(x) = A\sin\frac{\pi x}{l}` и :math:`V = 0`.

Обычной практикой является использование точного решения для
тестирования программной реализации. Однако численное решение
:math:`y_i^n` --- это только некоторое приближение точного. Мы не
знаем величину погрешности этого приближения и, следовательно, мы не
можем знать возникает ли разница между :math:`y_i^n` и
:math:`u_e(x_i,t_n)` из-за математического приближения или из-за
ошибок в программе. В частности, когда графики приближенного и точного
решений выглядят похоже, возникает соблазн сделать заключение о том,
что программная реализация работает правильно. Однако, даже если
графики выглядят похоже и точность кажется хорошей, все равно в
программной реализации могут присутствовать существенные ошибки.

Единственный способ использовать точное решение вида
:ref:`(19) <Eq:fdm-for-wave:verif:eq:exact_sol>` при верификации программы
заключается в выполнении ряда расчетов, сгущая сетку, вычисляя
интегральную погрешность на каждой сетке, и на основе этого оценить
скорость сходимости метода.

В нашем случае порядок сходимости метода равен 2 (см. следующий
раздел), значит, вычисленная скорость сходимости должна быть близка к
2 на достаточно мелкой сетке.

.. _fdm-for-wave:verif:manufact:

Пробные функции
---------------

Преимущество использования метода пробных функций заключается в том,
что мы можем тестировать все варианты в задаче
:ref:`(12) <Eq:fdm-for-wave:verif:eq:string_unhom>`--:ref:`(16) <Eq:fdm-for-wave:verif:eq:bound_right_unhom>`. Идея
метода заключается в том, что мы 
выбираем некоторую функцию и получаем соответствующие правую часть,
граничные и начальные условия, подставив эту функцию в задачу. Кроме
того, мы можем выбирать функцию, которая удовлетворяет граничным
условиям. Например,

.. math::
        
           u_e(x,t) = x(l - x) \sin t.
        

Подставляя эту функцию в уравнение
:ref:`(12) <Eq:fdm-for-wave:verif:eq:string_unhom>`, получаем 

.. math::
        
           -x(l-x) \sin t = -c^2 2\sin t + f \Rightarrow f = (2 c^2 -
           x(l-x)) \sin t
        

Начальные условия будут следующие

.. math::
        
           u(x,0) = I(x) = 0, \\ 
           \frac{\partial u(x,0)}{\partial t} = V(x) = x(l - x).
        

Для проверки программного кода, также нужно провести серию расчетов на
последовательности сгущающихся сеток, чтобы оценить скорость
сходимости в предположении, что некоторая мера :math:`E` погрешности
зависит от шагов сетки следующим образом

.. math::
        
           E = C_t \tau^r + C_x h^p,
        

где :math:`C_t, C_x, r` и :math:`p` --- постоянные. Постоянные
:math:`r` и :math:`p` характеризуют порядок сходимости по времени и
пространству соответственно. Из анализа погрешности аппроксимации
разностной схемы, мы ожидаем, что :math:`r = p = 2`.

Используя точное решение дифференциальной задачи, мы можем вычислить
меру погрешности :math:`E` на последовательности сгущающихся сеток и
проверить наличие второго порядка точности :math:`r = p = 2`. Мы не
будем оценивать константы :math:`C_t` и :math:`C_x`.

Удобно ввести один параметр дискретизации :math:`d = \tau = \hat{c} h`
с некоторой константой :math:`\hat{c}`. Так как :math:`\tau` и
:math:`h` связаны числом Куранта :math:`\tau = \gamma h/c`, положим
:math:`d = \tau`, тогда :math:`h = d c/\gamma`. Теперь выражения для меры в
случае, когда :math:`p=r`, погрешности упрощается

.. math::
        
           E = C_t \tau^r + C_x h^r = C_t d^r + C_x \left( \frac{c}{\gamma}
           \right)^r d^r = D d^r, \quad
           D = C_t + C_x \left( \frac{c}{\gamma}\right)^r.
        

Выбирая начальный параметр дискретизации :math:`d_0`, проводим серию
расчетов для последовательности уменьшающихся шагов :math:`d_k = 
2^{-k} d_0`. Уменьшение шага в два раза необязательно, это обычный
выбор. Для каждого расчета следует сохранять :math:`E` и
:math:`d`. Наиболее часто в качестве меры погрешности используются
:math:`\ell^2`- или :math:`\ell^{\infty}`-нормы сеточной функции
погрешности :math:`e_i^n`:

.. _Eq:fdm-for-wave:verif:eq:e_l2:

.. math::

    \tag{20}
    E = \| e_i^n\|_{\ell^2} = \left( \sum_{n = 0}^{K} \tau \sum_{i =
           0}^{K} (e_i^n)^2 \right)^{1/2}, \quad
           e_i^n = u_e(x_i, t_n) - y_i^n,
        

.. _Eq:fdm-for-wave:verif:eq:e_inf:

.. math::

    \tag{21}
    E = \| e_i^n \|_{\ell^{\infty}} = \max_{i,n} |e_i^n|.
        

При программной реализации на языке Python мы можем вычислить на
каждом временном шаге :math:`\sum_{i} (e_i^n)^2`, а затем аккумулировать
значение в некоторой переменной, например, ``e2_sum``. А на последнем
временном шаге выполнить что-то подобное ``sqrt(dt*dx*e2_sum)``. Для
:math:`\ell^{\infty}`-нормы нужно сравнить максимум погрешности на
временном слое ``e.max()`` с глобальной погрешностью, полученной на предыдущих
временных слоях, например, так: ``e_max = max(e_max, e.max())``.

Альтернативный способ измерения погрешности состоит в использовании
только пространственной нормы на временном шаге, например, при
значении времени :math:`T` (:math:`n = K`):

.. _Eq:fdm-for-wave:verif:eq:e_l2_lev:

.. math::

    \tag{22}
    E = \| e_i^K \|_{\ell^2} = \left( \sum_{i =
           0}^{K} (e_i^K)^2 \right)^{1/2}, \quad
           e_i^K = u_e(x_i, t_K) - y_i^K,
        

.. _Eq:fdm-for-wave:verif:eq:e_inf_lev:

.. math::

    \tag{23}
    E = \| e_i^K \|_{\ell^{\infty}} = \max_{0 \leq i \leq N} |e_i^K|.
        

Главное, что мера погрешности :math:`E` --- это одно число.

Пусть :math:`E_k` --- мера погрешности при расчете с номером :math:`k`
и пусть :math:`h_k` --- соответствующий параметр
дискретизации. Учитывая, что :math:`E_k = D d_k^r` мы можем оценить
:math:`r`, сравнивая два последовательных расчета

.. math::
        
           E_{k+1} = D d_{k+1}^r, \quad
           E_k = D d_k^r.
        

Отсюда, выражая :math:`r`, получим

.. math::
        
           r_k = \frac{\ln E_{k+1}/E_k}{\ln d_{k+1}/d_k}.
        

Так как :math:`r` зависит от :math:`k`, то добавили индекс к
:math:`r`: :math:`r_k`, :math:`k = 0, 1, \ldots, m - 2`, где :math:`m`
--- количество проведенных расчетов: :math:`(d_0, E_0), (d_1, E_1),\ldots, (d_m, E_m)`.

В нашем случае ожидается, что :math:`r = 2` и, следовательно,
последовательность :math:`r_k` должна стремиться к :math:`2` с ростом
:math:`k`.

.. _fdm-for-wave:verif:fdm_ex_sol:

Построение точного решения дискретной задачи
--------------------------------------------

Используя метод пробных функций и точное аналитическое решение
дифференциальной задачи, как упоминалось выше, мы можем оценить
скорость сходимости и правильное асимптотическое поведение. Опыт
показывает, что этот способ верификации достаточно хорош, так как
многие ошибки в программной реализации приводят к нарушению скорости
сходимости. Однако нам кажется, что для верификации программной
реализации, более точный тест тот, который позволяет проверить
совпадает ли численное решение с тем, которое точно должно быть. Это
требует точного знания численной погрешности, которого мы обычно не
можем получить. Однако, можно рассмотреть решение, для которого
численная погрешность равна нулю, т.е. решение исходной
дифференциальной задачи, которое так же является точным решением
разностной схемы. Это часто возникает, когда решением дифференциальной
задачи является полином небольшой степени. (Анализ погрешности
аппроксимации приводит к оценке погрешности, содержащей производные
решения. В нашем случае, погрешность аппроксимации содержит
производные четвертого порядка по пространству и времени. Выбирая
в качестве точного решения полином степени не выше третьей, мы получим
погрешность равную нулю.)

Рассмотрим построение точного решения как дифференциальной так и
разностной задачи. Выберем в качестве пробной функции полиномиальную
(второго порядка по пространственной переменной и первого по временной
переменной):

.. _Eq:fdm-for-wave:verif:eq:quad_sol:

.. math::

    \tag{24}
    u_e(x,t) = x(l - x)(1 + 0.5 t),
        

которое дает :math:`f(x,t) = 2(1+t)c^2`. Это решение удовлетворяет
однородным граничным условиям :ref:`(15) <Eq:fdm-for-wave:verif:eq:bound_left_unhom>`
и :ref:`(16) <Eq:fdm-for-wave:verif:eq:bound_right_unhom>`, а также начальным условиям
:ref:`(13) <Eq:fdm-for-wave:verif:eq:init_u_unhom>` с :math:`I(x) = x(l - x)` и
:ref:`(14) <Eq:fdm-for-wave:verif:eq:init_vel_unhom>` с :math:`V(x) = 0.5 x(l - x)`. 

Чтобы убедиться, что :math:`u_e` является точным решением разностной
схемы выполним вычисления

.. math::
        \begin{align*}
           u_{e\bar{t}t,i}^n &= x_i(x_i-l) (t)_{\bar{t}t}^n \nonumber\\ 
           &= x_i(x_i-l) \frac{1 + 0.5t_{n+1} - 2 - t_n + 1 + 0.5t_{n-1}}{\tau^2} \nonumber\\ 
           &=
           x_i(x_i-l) \tau \frac{0.5(n+1) - n + 0.5(n-1)}{\tau^2} = 0, \nonumber\\ 
           u_{e\bar{x}x,i}^n &= (1 + 0.5 t_n) (l x - x^2)_{\bar{x}x,i} \nonumber\\ 
           &= (1 + 0.5t_n) (l(x)_{\bar{x}x,i} - (x^2)_{\bar{x}x,i}) \nonumber\\ 
           &= - (1 + 0.5t_n) \frac{x_{i+1}^2 - 2x_i^2 + x_{i-1}^2}{h^2} \nonumber\\ 
           &= - (1 + 0.5t_n) h^2 \frac{(i+1)^2 - 2i^2 + (i-1)^2}{h^2} \nonumber\\ 
           &= -2(1 + 0.5 t_n). \nonumber
        \end{align*}

Отсюда, :math:`f_i^n = 2(1 + 0.5 t_n)c^2`. Кроме того,
:math:`u_e(x_i,0) = I(x_i)` и :math:`\frac{\partial u(x,0)}{\partial 
t} = V(x_i)`, а также :math:`u_e(x_i,t_n)` удовлетворяет разностному
уравнению для вычисления приближенного решения на первом временном
шаге :ref:`(18) <Eq:fdm-for-wave:verif:eq:y1_unhom>`.

Таким образом, точное решение дифференциальной задачи
:ref:`(24) <Eq:fdm-for-wave:verif:eq:quad_sol>` 
является точным решением разностной схемы. Мы
можем использовать его для проверки совпадения вычисленного
приближенного решения :math:`y_i^n` со значением :math:`u_e(x_i, t_n)`
с учетом машинной точности, независимо от значения временных шагов
:math:`h` и :math:`\tau`. Тем не менее, следует учитывать ограничения
на шаги из условия устойчивости, т.е. тесты следует выполнять только
на сетках удовлетворяющих условию устойчивости, которое в нашем случае
имеет вид :math:`\gamma \leq 1` и будет получено позже.


.. note::
   Произведение квадратичного или линейного выражений от разных
   независимых переменных, как показано выше, часто является точным
   решением как дифференциальной так и разностной задач, и может
   использоваться для верификации программной реализации алгоритма.
   
   Однако, для одномерного волнового уравнения вида
   :math:`\frac{\partial^2 u}{\partial t^2} = c^2 \frac{\partial^2
   u}{\partial t^2}`, как мы увидим далее, существует другой способ
   генерации точных решений, который состоит в только выборе числа
   Куранта равным единице, :math:`\gamma = 1`!




.. Local Variables:

.. doconce-chapter-nickname: "fdm-for-wave"

.. doconce-section-nickname: "verif"

.. End:

