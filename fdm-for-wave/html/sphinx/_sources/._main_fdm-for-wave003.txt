.. !split

.. _fdm-for-wave:exercises:

Упражнения          (1)
=======================

.. --- begin exercise ---

.. _fdm-for-wave:exercises:1:

Exercise 1: Моделирование стоячей волны
---------------------------------------

Цель данного упражнения --- провести моделирование стоячей волны на
отрезке :math:`[0, l]` и проиллюстрировать расчет
погрешности. Стоячие волны порождаются начальным условием

.. math::
        
        	u(x,0) = A \sin \frac{\pi m x}{l}
        

где :math:`m` --- целое число, :math:`A` --- заданная
амплитуда. Соответствующее точное решение может быть получено:

.. math::
        
        u_e(x, t) = A \sin\frac{\pi m x}{l} \cos\frac{\pi m c t}{l}.
        

1. Показать, что для функции :math:`\sin kx \cos \omega t` длина волны в
  пространстве :math:`\lambda = 2\pi/k` и период по времени :math:`P =
  2\pi/\omega`. Используйте эти выражения для нахождения соответствующих
  пространственной длины волны и периода по времени функции :math:`u_e`. 

2. Импортировать функцию ``solver`` из сценария
  `wave1d_1.py <src-fdm-for-wave/wave1d_1.py>`__ в новый файл, где
  функция ``viz`` будет реализована так, что будут строится
  графики содержащие или численное и точное решение, или
  погрешность.

3. Создать анимацию, где будет иллюстрироваться как погрешность
  :math:`e_i^n = u(x,t_n) - y_i^n` будет расти и уменьшаться со
  временем. Также создать анимацию совместно изменяющихся
  :math:`y` и :math:`u_e`.

.. --- begin hint in exercise ---

**Hint 1.**
Необходим достаточно длинный расчет, чтобы увидеть существенное
несоответствие между точным и приближенным решениями.

.. --- end hint in exercise ---

.. --- begin hint in exercise ---

**Hint 2.**
Возможный набор параметров: :math:`l = 12`, :math:`m = 9`, :math:`c=2`, :math:`A=1`, :math:`N_x =
80`, :math:`\gamma = 0.8`. Сеточная функция погрешности :math:`e^n` можно вычислить
для 10 периодов, в то время как для того, чтобы увидеть существенную
разницу между точным и приближенным решениями, нужно 20 - 30 периодов.

.. --- end hint in exercise ---

Filename: ``wave_standing.py``.

.. Closing remarks for this Exercise

Remarks
~~~~~~~

Важными параметрами, влияющими на качество численного решения,
являются число Куранта :math:`\gamma=c\tau/h` и соотношение :math:`kh`,
пропорциональное числу узлов сетки на длину волны.

.. --- end exercise ---

.. --- begin exercise ---

.. _fdm-for-wave:exercises:2:

Exercise 2: Добавить сохранение решения в функции действий пользователя
-----------------------------------------------------------------------

Расширить функцию ``plot_u`` в файле
`wave1d_1.py <src-fdm-for-wave/wave1d_1.py>`__, чтобы также сохранялось
решение ``y`` в 
список. С этой целью объявите в функции ``viz`` вне ``plot_u``
переменную ``all_u`` как пустой список выполните операцию
добавления элемента к списку внутри функции ``plot_u``. Заметьте,
что функция, как ``plot_u``, внутри другой функции, как ``viz``,
помнит все локальные переменные функции ``viz``, включая ``all_u``,
даже когда ``plot_u`` вызывается (как ``user_action``) из функции
``solver``. Протестируйте как ``all_u.append(y)`` так и
``all_u.append(y.copy)``. Почему одна из этих конструкций не
выполняет сохранение решения корректно? Пусть функция ``viz``
возвращает список ``all_u``, преобразованный в двумерный массив
``numpy``.
Filename: ``wave1d_1_store.py``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fdm-for-wave:exercises:3:

Exercise 3: Использование класса для функции действий пользователя
------------------------------------------------------------------

Переделать :ref:`fdm-for-wave:exercises:2`, используя класс для функции
``user_action``, т.е. определить класс ``Action``, у которого
список ``all_u`` является свойством, и реализовать функцию действий
пользователя как метод этого класса (специальный метод ``__call__``
--- естественный выбор). Такая версия исключает ситуацию, когда
функция действий пользователя зависит от параметров, определенных
вне функции (такую как в  :ref:`fdm-for-wave:exercises:2`).
Filename: ``wave1d_1_s2c.py``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fdm-for-wave:exercises:4:

Exercise 4: Сравнение нескольких чисел Куранта на одном видео
-------------------------------------------------------------

Цель упражнения --- сделать видео, на котором отображается
несколько кривых, соответствующих разным числам
Куранта. Импортировать ``solver`` из
`wave1d_1.py <src-fdm-for-wave/wave1d_1.py>`__
в новый файл ``wave_compare.py``. Заново
реализовать функцию ``viz`` так, чтобы она получала в качестве
аргумента список значений ``gamma`` и создавала анимацию с
решениями, соответствующими заданным значениям ``gamma``. Функция
``plot_u`` должна быть изменена для того, чтобы сохранять значения
в массив (см. :ref:`fdm-for-wave:exercises:2` или
:ref:`fdm-for-wave:exercises:3`), ``solver`` должен выполняться для
каждого значения числа Куранта, и, наконец, на всех временных слоях
должны быть построены графики решений и решения должны быть сохранены
в файл. 

Главная проблема такой визуализации заключается в том, что мы
должны быть уверены, что графики решений на одном кадре
соответствуют одному и тому же моменту времени. Простейший способ
устранения проблемы --- это оставить шаги по времени и пространству
постоянными, а менять скорость волны :math:`c` для того, чтобы
изменялось число Куранта.
Filename: ``wave_compare.py``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fdm-for-wave:exercises:pr1:

Project 5: Исчисления с одномерными сеточными функциями
-------------------------------------------------------

Этот проект --- изучение интегрирования и дифференцирования сеточных
функций, как в скалярной так и в векторизованной реализации. Пусть задана
сеточная функция :math:`f_i` на одномерной пространственной сетке

.. math::
        
        	\omega_h = \{ x_i = a + ih, \ i = 0, 1, \ldots N, \  h = (b - a)/N
        	\},
        

заданной на отрезке :math:`[a, b]`.

**1)** Определить разностную производную от :math:`f_i`, используя центральную
  производную во внутренних узлах секи и 
  направленные производные на концах отрезков. Реализовать программно
  скалярную версию вычислений в виде функции Python и написать
  соответствующий юнит-тест для линейной функции :math:`f(x) = 4x - 
  2.5`, для которой разностные производные должны совпадать с
  непрерывными.

**2)** Векторизовать реализацию вычисления разностных производных.
  Расширить юнит-тест для проверки адекватности такой реализации.

**3)** Для вычисления дискретного интеграла :math:`F_i` от :math:`f_i`,
  предположим, что сеточная функция :math:`f_i` изменяется линейно
  между узлами сетки (линейна или кусочно-линейна). Пусть :math:`f(x)` ---
  линейная интерполяция :math:`f_i`. Тогда имеем

.. math::
        
          F_i = \int_{x_0}^{x_i} f(x)dx
        

Точный интеграл кусочно-линейной от функции :math:`f(x)` дается формулой
трапеций. Показать, что если вычислено значение :math:`F_i`, то :math:`F_{i+1}`
можно получить следующим образом 

.. math::
        
        	F_{i+1} = F_i + \frac{1}{2} \left( f_i + f_{i+1} \right)h
        

Создать функцию скалярной реализации дискретного интеграла как
сеточной функции. Это значит, что функция должна возвращать :math:`F_i` для
:math:`i = 0, 1, \ldots, N`. Для юнит-тестирования используйте тот факт, что
описанный выше дискретный интеграл от линейной функции (например,
:math:`f(x) = 4x - 2.5`) дает точное значение интеграла.

**4)** Векторизовать программную реализацию дискретного
интеграла. Расширить юнит-тест для проверки адекватности такой
реализации. 

**5)** Создать класс ``MeshCalculus``, который позволит интегрировать и
дифференцировать сеточные функции. В классе должны быть определены
методы, которые вызывают созданные раньше функции. Ниже приведен
пример использования класса: 

.. code-block:: python

    import numpy as np
    calc = MeshCalculus(vectorized=True)
    x = np.linspace(a, b, 11)     # сетка
    f = np.exp(x)                 # сеточная функция
    df = calc.differentiate(f, x) # разностная производная
    F = calc.integrate(f, x)      # дискретный интеграл

.. --- begin hint in exercise ---

**Hint.**
Представьте рекуррентную формулу для :math:`F_{i+1}` в виде суммы. Создайте
массив, содержащий элементы суммы, и используйте "cumsum"
(``numpy.cumsum``) операцию для вычисления накапливаемой суммы:
``numpy.cumsum([1 ,3, 5])`` даст ``[1, 4, 9]``.

.. --- end hint in exercise ---

Filename: ``mesh_calculus_1d.py``.

.. --- end exercise ---

