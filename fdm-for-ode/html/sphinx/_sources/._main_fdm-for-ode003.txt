.. !split

.. _fdm-for-ode:exercises:

Упражнения и задачи
===================

.. --- begin exercise ---

.. _fdm-for-ode:exercises:1:

Exercise 1: Использование ряда Тейлора для вычисления :math:`y^1`
-----------------------------------------------------------------

Альтернативный способ вывода
:ref:`(7) <Eq:fdm-for-ode:fdd:eq:vibr:efds:init:1>` для
вычисления :math:`y^1` заключается в использовании следующего
ряда Тейлора:

.. _Eq:fdm-for-ode:exercises:eq:1:

.. math::

    \tag{28}
    u(t_1) \approx u(0) + \tau u'(0) + \frac{\tau^2}{2} u''(0) + O(\tau^3)
        

Используя уравнение :ref:`(1) <Eq:fdm-for-ode:fdd:basic_model:eq:vibr>` и начальное условие для
производной :math:`u'(0) = 0`, покажите, что такой способ
также приведет к :ref:`(7) <Eq:fdm-for-ode:fdd:eq:vibr:efds:init:1>`. Более общее условие
для :math:`u'(0)` имеет вид :math:`u'(0) = V`. Получите
формулу для вычисления :math:`y^1` двумя способами.

.. --- end exercise ---

.. --- begin exercise ---

.. _fdm-for-ode:exercises:2:

Exercise 2: Использование точного дискретного решения для тестирования
----------------------------------------------------------------------

Написать тестовую функцию в отдельном файле, которая использует
точное дискретное решение :ref:`(13) <Eq:fdm-for-ode:analysis:eq:ex:discr>` для
проверки реализации функции ``solver``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fdm-for-ode:exercises:3:

Exercise 3: Использование линейной и квадратичной функций для тестирования
--------------------------------------------------------------------------

Упражнение является обобщением задачи :ref:`fdm-for-ode:exercises:pr:1`
на более общую задачу :ref:`(17) <Eq:fdm-for-ode:gen:eq:gen>` в случаях, когда
затухание линейное или квадратичное. Решите несколько подзадач и
посмотрите как меняются результаты и настройки программы для случаев
разных затуханий. При модификации кода из задачи
:ref:`fdm-for-ode:exercises:pr:1`, используйте ``sympy``, который выполнит
основную часть работы для анализа обобщенной задачи.

.. --- end exercise ---

.. --- begin exercise ---

.. _fdm-for-ode:exercises:4:

Exercise 4: Показать линейный рост фазы со временем
---------------------------------------------------

Рассмотрим точное и приближенное решения :math:`I\cos(\omega t)` и 
:math:`I\cos(\tilde{\omega} t)`, соответственно. Определить погрешность фазы
как задержку по времени пика :math:`I` точного решения и соответствующего
пика приближенного решения после :math:`m` периодов колебаний. Показать, что
эта погрешность зависит линейно от :math:`m`.

.. --- end exercise ---

.. --- begin exercise ---

.. _fdm-for-ode:exercises:5:

Exercise 5: Улучшить точность регуляризацией частоты
----------------------------------------------------

Согласно :ref:`(12) <Eq:fdm-for-ode:analysis:eq:omega:exp>` численная частота
отклоняется от точной на величину :math:`\omega^3\tau^2/24 > 0`. Замените
параметр ``omega`` в функции ``solver`` из
`vib_undamped.py <src-fdm-for-ode/vib_undamped.py>`__ выражением
:math:`\omega*(1 - 1./24)*\omega^2\tau^2`  и проанализируйте как такая
регуляризация влияет на точность.

.. --- end exercise ---

.. --- begin exercise ---

.. _fdm-for-ode:exercises:6:

Exercise 6: Визуализация аппроксимации разностных производных для косинуса
--------------------------------------------------------------------------

Введем следующую величину

.. math::
        
        	E = \frac{u_{\bar{t}t}^n}{u''(t_n)}
        

для измерения погрешности аппроксимации второй разностной
производной. Вычислить :math:`E` для функции вида :math:`u(t) = \exp(i\omega t)`
(:math:`i` --- мнимая единица) и показать, что 

.. math::
        
        	E = \left( \frac{2}{\omega\tau} \right)^2 \sin^2\left( \frac{\omega\tau}{2}
        	\right).
        

Построить график зависимости :math:`E` от :math:`p = \omega\tau \in [0,
\pi]`. Отклонение кривой от единицы показывает погрешность
аппроксимации. Также разложите :math:`E` в ряд Тейлора по :math:`p` до четвертой
степени, используя ``sympy``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fdm-for-ode:exercises:7:

Exercise 7: Минимизация использования памяти
--------------------------------------------

Сценарий `vib.py <src-fdm-for-ode/vib.py>`__ хранит все значения
приближенного решения :math:`y^0, y^1, \ldots, y^{N}` в памяти, что 
удобно для последующего построения графиков. Сделать версию этого
сценария, где только три последних значения :math:`y^{n+1}, y^n, y^{n-1}`
хранятся в памяти. Организуйте запись каждых посчитанных пар
:math:`(t_{n+1}, y^{n+1})` в файл. Реализуйте визуализацию данных из файла.

.. --- end exercise ---

.. --- begin exercise ---

.. _fdm-for-ode:exercises:pr:1:

Problem 8: Использование линейной и квадратичной функций для тестирования
-------------------------------------------------------------------------

Рассмотрим задачу для ОДУ:

.. math::
        
           u'' + \omega^2 u = f(t), \quad u(0) = U,
           \quad u'(0) = V, \quad t \in (0, T].
        

1. Аппроксимируем уравнение разностной схемой :math:`y_{\bar{t}t}^n + \omega^2 y^n = f^n`.

2. Вывести уравнение для нахождения приближенного решения :math:`y^1` на первом временном шаге.

3. Для тестирования реализации алгоритма воспользуемся методом пробных функций. Выберем :math:`u_e(t) = ct + d`.  Найти :math:`c` и :math:`d` из начальных условий. Вычислить соответствующую функцию источника :math:`f`. Покажите, что :math:`u_e` является точным решением соответствующей разностной схемы. 

4. Используйте ``sympy`` для выполнения символьных вычислений из пункта 2. Ниже представлен каркас такой программы: 

.. code-block:: python

    # -*- coding: utf-8 -*-
    
    import sympy as sym
    V, t, U, omega, tau = sym.symbols('V t U omega tau')  # глобальные символы
    f = None  # глобальная переменная для функции источника ОДУ
    
    def ode_source_term(u):
        """
        Возвращает функцию источника ОДУ, равную u'' + omega**2*u.
        u --- символьная функция от t."""
        return sym.diff(u(t), t, t) + omega**2*u(t)
    
    def residual_discrete_eq(u):
        """
        Возвращает невязку разностного уравнения на заданной u.
        """
        R = ...
        return sym.simplify(R)
    
    def residual_discrete_eq_step1(u):
        """
        Возвращает невязку разностного уравнения на первом шаге 
        на заданной u.
        """
        R = ...
        return sym.simplify(R)
    
    def DtDt(u, tau):
    	"""
    	Возвращает вторую разностную производную от u.
    	u --- символьная функция от t.
        """
        return ...
    
    def main(u):
    	"""
    	Задавая некоторое решение u как функцию от t, используйте метод
    	пробных функций для вычисления функции источника f и проверьте 
    	является ли u решением и разностной задачи.
        """
        print '=== Проверка точного решения: %s ===' % u
        print "Начальные условия u(0)=%s, u'(0)=%s:" % \
              (u(t).subs(t, 0), sym.diff(u(t), t).subs(t, 0))
    
        # Метод пробных функций требует подбора f
        global f
        f = sym.simplify(ode_lhs(u))
    
        # Невязка разностной задачи (должна быть 0)
        print 'residual step1:', residual_discrete_eq_step1(u)
        print 'residual:', residual_discrete_eq(u)
    
    def linear():
        main(lambda t: V*t + U)
    
    if __name__ == '__main__':
        linear()

.. Local Variables:

.. doconce-chapter-nickname: "fdm-for-ode"

.. doconce-section-nickname: "exercises"

.. End:

.. Local Variables:

.. doconce-chapter-nickname: "fdm-for-ode"

.. End:

.. --- end exercise ---
