
<!DOCTYPE html>
<html>
<head>
<title>Методические материалы: Разностные схемы для ОДУ колебаний</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
   @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
   @import url(http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
   @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

body { font-family: 'Droid Serif'; }
h1, h2, h3 {
  font-family: 'Yanone Kaffeesatz';
  font-weight: normal;
}
.remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

</style>
</head>

<body>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<textarea id="source">

class: center, middle

# Методические материалы: Разностные схемы для ОДУ колебаний


### **С. Лемешевский** at Институт математики НАН Беларуси


### Mar 12, 2017

---

# Простейшая модель колебательного процесса
<div id="fdm-for-ode:fdd:basic_model"></div>

$$
\begin{align*}
   u'' + \omega^2 u = 0, \quad t \in (0, T],\\
	u(0) = U,\quad  u'(0) = 0.
\end{align*}
$$

Точное решение 
$$
u(t) = U\cos{\omega t},
$$

описывает колебания с постоянной амплитудой \\( U \\) и
угловой частотой \\( \omega \\). Соответствующий период колебаний равен
\\( P = 2\pi/\omega \\).

---


## Разностная схема
<div id="fdm-for-ode:fdd:fdd"></div>

* Введем равномерную сетку по переменной \\( t \\) с шагом \\( \tau \\):

$$
\omega_\tau = \{ t_n = n\tau, \ n = 0, 1, \ldots N \}.
$$

* Простейшая разностная схема

$$
\frac{y^{n+1} - 2 y^{n} + y^{n-1}}{\tau^2} = -\omega^2 y^n.
$$

* Для формулировки вычислительного алгоритма, предположим, что мы уже знаем значение \\( y^{n-1} \\) и \\( y^{n} \\). Тогда из мы можем выразитьнеизвестное значение \\( y^{n+1} \\): 

$$
y^{n+1} = 2y^n - y^{n-1} - \tau^2 \omega^2 y^n.
$$

---

## Вычисление решения на первом шаге
<div id="fdm-for-ode:fdd:first_step"></div>

Очевидно, что для вычисления \\( y^1 \\) необходимо знать неопределенное
значение \\( y^{-1} \\) при \\( t = -\tau \\).

Аппроксимируем начальное условие \\( u'(0) = 0 \\) центральной разностной
производной:

$$
\frac{y^{1} - y^{-1}}{2\tau} = 0 \Rightarrow y^1 = y^{-1}
$$

Подставляя последнее в разностную схему при \\( n=0 \\), получим

$$
y^1 = y^0 - \frac{1}{2} \tau^2\omega^2 y^0.
$$

---

## Вычислительный алгоритм
<div id="fdm-for-ode:fdd:alg"></div>

1. \\( y^0 = U \\)
2. вычисляем \\( y^1 \\)
3. для \\( n = 1, 2, \ldots \\),
   a. вычисляем \\( y^n \\)


Более строго вычислительный алгоритм напишем на Python:


```python
t = linspace(0, T, N+1)  # сетка по времени
tau = t[1] - t[0]        # постоянный временной шаг
u = zeros(N+1)           # решение
   
u[0] = U
u[1] = u[0] - 0.5*tau**2*omega**2*u[0]
for n in range(1, N):
    u[n+1] = 2*u[n] - u[n-1] - tau**2*omega**2*u[n]
```

---

## Безындексные обозначения
<div id="fdm-for-ode:fdd:index_free"></div>

Разностную схему можно записать, используя безындексные
обозначения.

*Левая* и *правая разностные производные* 

$$
y_{\bar{t}} \equiv \frac{y^{n} - y^{n-1}}{\tau}, \quad
   y_{t} \equiv \frac{y^{n+1} - y^{n}}{\tau}.
$$

*Вторая разностная производная*

$$
y_{\bar{t}t} = \frac{y_t - y_{\bar{t}}}{\tau} = \frac{y^{n+1} - 2y^{n} + y^{n-1}}{\tau^2}.
$$

*Центральная разностная производная*:

$$
y_{\mathring{t}} = \frac{y^{n+1} - y^{n-1}}{2\tau}.
$$

<!-- Local Variables: -->
<!-- doconce-chapter-nickname: "fdm-for-ode" -->
<!-- doconce-section-nickname: "fdd" -->
<!-- End: -->

---

# Программная реализация
<div id="fdm-for-ode:impl"></div>

---

## Функция-решатель (Солвер)
<div id="fdm-for-ode:impl:solver"></div>



```python
def solver(U, omega, tau, T):
    """
    Решается задача
    u'' + omega**2*u = 0 для t из (0,T], u(0)=U и u'(0)=0,
    конечно-разностным методом с постоянным шагом tau
    """
    tau = float(tau)
    Nt = int(round(T/tau))
    u = np.zeros(Nt+1)
    t = np.linspace(0, Nt*tau, Nt+1)

    u[0] = U
    u[1] = u[0] - 0.5*tau**2*omega**2*u[0]
    for n in range(1, Nt):
        u[n+1] = 2*u[n] - u[n-1] - tau**2*omega**2*u[n]
    return u, t
```

---

## Построение графиков


```python
def visualize(u, t, U, omega):
    plt.plot(t, u, 'r--o')
    t_fine = np.linspace(0, t[-1], 1001)  # мелкая сетка для точного решения
    u_e = u_exact(t_fine, U, omega)
    plt.hold('on')
    plt.plot(t_fine, u_e, 'b-')
    plt.legend([u'приближенное', u'точное'], loc='upper left')
    plt.xlabel('\\( t \\)')
    plt.ylabel('\\( u \\)')
    tau = t[1] - t[0]
    plt.title('\\( \\tau =  \\) %g' % tau)
    umin = 1.2*u.min();  umax = -umin
    plt.axis([t[0], t[-1], umin, umax])
    plt.savefig('tmp1.png');  plt.savefig('tmp1.pdf')
```

---

## Основная программа


```python
U = 1
omega = 2*pi
tau = 0.05
num_periods = 5
P = 2*np.pi/tau    #  один период
T = P*num_periods
u, t = solver(U, omega, tau, T)
visualize(u, t, U, omega, tau)
```

---


## Интерфейс пользователя: командная строка


```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--U', type=float, default=1.0)
parser.add_argument('--omega', type=float, default=2*np.pi)
parser.add_argument('--tau', type=float, default=0.05)
parser.add_argument('--num_periods', type=int, default=5)
a = parser.parse_args()
U, omega, tau, num_periods = a.U, a.omega, a.tau, a.num_periods
```

Стандартный вызов основной программы выглядит следующим образом:

```shell
Terminal> python vib_undamped.py --num_periods 20 --tau 0.1
```

<!-- Local Variables: -->
<!-- doconce-chapter-nickname: "fdm-for-ode" -->
<!-- doconce-section-nickname: "impl" -->
<!-- End: -->

---

# Верификация реализации алгоритма
<div id="fdm-for-ode:verif"></div>

---

## Простейшие способы тестирования
<div id="fdm-for-ode:verif:hand"></div>

* **Тестирование на простейших решениях**: \\( u=\textrm{const} \\) или \\( u = ct + d \\) не применимы здесь (без правой части в уравнении).
* **Ручные вычисления**: 

вычислить значений \\( y^1, y^2 \\) и \\( y^3 \\) и сравнить с результатом программы.


```python
def test_three_steps():
    from math import pi
    U = 1;  omega = 2*pi;  tau = 0.1;  T = 1
    u_by_hand = np.array([
	    1.000000000000000,
	    0.802607911978213,
	    0.288358920740053])
    u, t = solver(U, omega, tau, T)
    diff = np.abs(u_by_hand - u[:3]).max()
    tol = 1E-14
    assert diff < tol
```

---

## Оценка скорости сходимости
<div id="fdm-for-ode:verif:conv:est"></div>

Чтобы оценить скорость сходимости для рассматриваемой задачи, нужно
выполнить

* провести \\( m \\) расчетов, уменьшая на каждом из них шаг в два раза: \\( \tau_k = 2^{-k}\tau_0 \\), \\( k = 0, 1, \ldots, m-1 \\), 
* вычислить \\( L_2 \\) -норму погрешности для каждого расчета \\( \varepsilon_k = \sqrt{\sum_{n=0}^{N-1} (y^n -u_e(t_n)) \tau_k} \\),
* оценить скорость сходимости на основе двух последовательных
  экспериментов \\( (\tau_{k-1}, \varepsilon_{k-1}) \\) и
  \\( (\tau_{k}, \varepsilon_{k}) \\)

---

## Программная реализация
<div id="fdm-for-ode:verif:conv:impl"></div>


```python
def convergence_rates(m, solver_function, num_periods=8):
    """
    Возвращает m-1 эмпирическую оценку скорости сходимости, 
    полученную на основе m расчетов, для каждого из которых 
    шаг по времени уменьшается в два раза.
    solver_function(U, omega, tau, T) решает каждую задачу, 
    для которой T, получается на основе вычислений для 
    num_periods периодов.
    """
    from math import pi
    omega = 0.35; U = 0.3       # просто заданные значения
    P = 2*pi/omega              # период
    tau = P/30                  # 30 шагов на период 2*pi/omega
    T = P*num_periods

    tau_values = []
    E_values = []
    for i in range(m):
        u, t = solver_function(U, omega, tau, T)
        u_e = u_exact(t, U, omega)
        E = np.sqrt(tau*np.sum((u_e-u)**2))
        tau_values.append(tau)
        E_values.append(E)
        tau = tau/2

    r = [np.log(E_values[i-1]/E_values[i])/
         np.log(tau_values[i-1]/tau_values[i])
         for i in range(1, m, 1)]
    return r
```

Ожидаемая скорость сходимости --- 2.

---

## Юнит-тест для скорости сходимости

Используем последнего элемента `r[-1]` в юнит-тесте:


```python
def test_convergence_rates():
    r = convergence_rates(m=5, solver_function=solver, num_periods=8)
    tol = 0.1
    assert abs(r[-1] - 2.0) < tol
```

<!-- Local Variables: -->
<!-- doconce-chapter-nickname: "fdm-for-ode" -->
<!-- doconce-section-nickname: "verif" -->
<!-- End: -->

---


# Проведение вычислительного эксперимента
<div id="fdm-for-ode:long_time"></div>

---


## Влияние шага аппроксимации при моделировании

.center[<img src="fig-fdm-for-ode/vib-fig-1.png" width=800><p><em>Эффект от уменьшения шага вдвое <div id="fdm-for-ode:long_time:fig:1"></div></em></p>]

* Похоже, что численное решение корректно передает амплитуду колебаний
* Наблюдается погрешность при расчете угловой частоты, которая
  уменьшается при уменьшении шага.
* Суммарная погрешность угловой частоты увеличивается со временем.

---

## Использование изменяющихся графиков
<div id="fdm-for-ode:long_time:mov_figs"></div>

* При моделировании на длительном временном отрезке нам нужно строить
  график "следующий" за решением.
* Пакет [SciTools](https://github.com/hplgit/scitools)
  содержит удобный инструмент для этого: `MovingPlotWindow`.

Пример вызова:

```shell
Terminal> python vib_undamped.py --dt 0.05 --num_periods 40
```

[Видео](mov-fdm-for-ode/vib.html)

---

## Использование Bokeh для сравнения графиков
<div id="fdm-for-ode:long_time:bokeh"></div>


---


## Как выглядит код для построения графиков с помощью Bokeh


```python
def bokeh_plot(u, t, legends, U, omega, t_range, filename):
	"""
	Строится график зависимости приближенного решения от t с 
	использованием библиотеки Bokeh.
	u и t - списки (несколько экспериментов могут сравниваться).
	легенды содержат строки для различных пар u,t.
    """
	if not isinstance(u, (list,tuple)):
		u = [u]  
	if not isinstance(t, (list,tuple)):
		t = [t]  
	if not isinstance(legends, (list,tuple)):
		legends = [legends] 

	import bokeh.plotting as plt
	plt.output_file(filename, mode='cdn', title=u'Сравнение с помощью Bokeh')
	# Предполагаем, что все массивы t имеют одинаковые размеры
	t_fine = np.linspace(0, t[0][-1], 1001)  # мелкая сетка для точного решения
	tools = 'pan,wheel_zoom,box_zoom,reset,'\ 
	        'save,box_select,lasso_select'
	u_range = [-1.2*U, 1.2*U]
	font_size = '8pt'
	p = []  # список графических объектов
	# Создаем первую фигуру
	p_ = plt.figure(
		width=300, plot_height=250, title=legends[0],
		x_axis_label='t', y_axis_label='u',
		x_range=t_range, y_range=u_range, tools=tools,
		title_text_font_size=font_size)
	p_.xaxis.axis_label_text_font_size=font_size
	p_.yaxis.axis_label_text_font_size=font_size
	p_.line(t[0], u[0], line_color='blue')
	# Добавляем точное решение
	u_e = u_exact(t_fine, U, omega)
	p_.line(t_fine, u_e, line_color='red', line_dash='4 4')
	p.append(p_)
	# Создаем оставшиеся фигуры и добавляем их оси к осям первой фигуры
	for i in range(1, len(t)):
		p_ = plt.figure(
			width=300, plot_height=250, title=legends[i],
			x_axis_label='t', y_axis_label='u',
			x_range=p[0].x_range, y_range=p[0].y_range, tools=tools,
			title_text_font_size=font_size)
		p_.xaxis.axis_label_text_font_size = font_size
		p_.yaxis.axis_label_text_font_size = font_size
		p_.line(t[i], u[i], line_color='blue')
		p_.line(t_fine, u_e, line_color='red', line_dash='4 4')
		p.append(p_)
		
	# Располагаем все графики на сетке с 3 графиками в строке
	grid = [[]]
	for i, p_ in enumerate(p):
		grid[-1].append(p_)
		if (i+1) % 3 == 0:
			# Новая строка
			grid.append([])
	plot = plt.gridplot(grid, toolbar_location='left')
	plt.save(plot)
	plt.show(plot)
```

<!-- Local Variables: -->
<!-- doconce-chapter-nickname: "fdm-for-ode" -->
<!-- doconce-section-nickname: "long_time" -->
<!-- End: -->





</textarea>
<script src="http://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript">
</script>
<script type="text/javascript">
  var slideshow = remark.create();
</script>
</body>
</html>
