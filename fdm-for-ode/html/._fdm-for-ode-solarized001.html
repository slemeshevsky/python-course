<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Разностные схемы для ОДУ колебаний">
<meta name="keywords" content="Разностная схема,Разностная производная,Разностная производная левая,Разностная производная  правая,Разностная производная вторая,Разностная производная центральная,ArgumentParser">

<title>Разностные схемы для ОДУ колебаний</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Содержание',
               1,
               'table_of_contents',
               'table_of_contents'),
              (u'\u041a\u043e\u043d\u0435\u0447\u043d\u043e-\u0440\u0430\u0437\u043d\u043e\u0441\u0442\u043d\u0430\u044f \u0434\u0438\u0441\u043a\u0440\u0435\u0442\u0438\u0437\u0430\u0446\u0438\u044f',
               1,
               u'fdm-for-ode:fdd',
               u'fdm-for-ode:fdd'),
              (u'\u0411\u0430\u0437\u043e\u0432\u0430\u044f \u043c\u043e\u0434\u0435\u043b\u044c \u043a\u043e\u043b\u0435\u0431\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430',
               2,
               u'fdm-for-ode:fdd:basic_model',
               u'fdm-for-ode:fdd:basic_model'),
              (u'\u0420\u0430\u0437\u043d\u043e\u0441\u0442\u043d\u0430\u044f \u0441\u0445\u0435\u043c\u0430',
               2,
               u'fdm-for-ode:fdd:fdd',
               u'fdm-for-ode:fdd:fdd'),
              (u'\u0412\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c',
               2,
               u'fdm-for-ode:fdd:alg',
               u'fdm-for-ode:fdd:alg'),
              (u'\u0411\u0435\u0437\u044b\u043d\u0434\u0435\u043a\u0441\u043d\u044b\u0435 \u043e\u0431\u043e\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f',
               2,
               u'fdm-for-ode:fdd:index_free',
               u'fdm-for-ode:fdd:index_free'),
              (u'\u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u0430\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f',
               1,
               u'fdm-for-ode:impl',
               u'fdm-for-ode:impl'),
              (u'\u0424\u0443\u043d\u043a\u0446\u0438\u044f-\u0440\u0435\u0448\u0430\u0442\u0435\u043b\u044c (\u0421\u043e\u043b\u0432\u0435\u0440)',
               2,
               u'fdm-for-ode:impl:solver',
               u'fdm-for-ode:impl:solver'),
              (u"\u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u043e\u0439 $u'(t)$",
               2,
               u'fdm-for-ode:impl:comp_diff',
               u'fdm-for-ode:impl:comp_diff'),
              (u'\u0412\u0435\u0440\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u0430',
               1,
               u'fdm-for-ode:verif',
               u'fdm-for-ode:verif'),
              (u'\u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0432 \u0440\u0443\u0447\u043d\u0443\u044e',
               2,
               u'fdm-for-ode:verif:hand',
               u'fdm-for-ode:verif:hand'),
              (u'\u0422\u0435\u0441\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043d\u0430 \u043f\u0440\u043e\u0441\u0442\u0435\u0439\u0448\u0438\u0445 \u0440\u0435\u0448\u0435\u043d\u0438\u044f\u0445',
               2,
               u'fdm-for-ode:verif:',
               u'fdm-for-ode:verif:'),
              (u'\u0410\u043d\u0430\u043b\u0438\u0437 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 \u0441\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438',
               2,
               u'fdm-for-ode:verif:conv',
               u'fdm-for-ode:verif:conv'),
              (u'\u041e\u0446\u0435\u043d\u043a\u0430 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 \u0441\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438',
               3,
               u'fdm-for-ode:verif:conv:est',
               u'fdm-for-ode:verif:conv:est'),
              (u'\u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u0430\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f',
               3,
               u'fdm-for-ode:verif:conv:impl',
               u'fdm-for-ode:verif:conv:impl'),
              (u'\u0411\u0435\u0437\u0440\u0430\u0437\u043c\u0435\u0440\u043d\u0430\u044f \u043c\u043e\u0434\u0435\u043b\u044c',
               1,
               u'fdm-for-ode:scaled',
               u'fdm-for-ode:scaled'),
              (u'\u041f\u0440\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u044d\u043a\u0441\u043f\u0435\u0440\u0438\u043c\u0435\u043d\u0442\u0430',
               1,
               u'fdm-for-ode:long_time',
               u'fdm-for-ode:long_time'),
              (u'\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0438\u0437\u043c\u0435\u043d\u044f\u044e\u0449\u0438\u0445\u0441\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432',
               2,
               u'fdm-for-ode:long_time:mov_figs',
               u'fdm-for-ode:long_time:mov_figs'),
              (u'\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0430\u043d\u0438\u043c\u0430\u0446\u0438\u0438',
               2,
               u'fdm-for-ode:long_time:anim',
               u'fdm-for-ode:long_time:anim'),
              (u'\u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0435 \u0432\u0438\u0434\u0435\u043e \u0444\u043e\u0440\u043c\u0430\u0442\u044b',
               3,
               u'fdm-for-ode:long_time:anim:std',
               u'fdm-for-ode:long_time:anim:std'),
              (u'\u0423\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u044f \u0438 \u0437\u0430\u0434\u0430\u0447\u0438',
               1,
               u'fdm-for-ode:exercises',
               u'fdm-for-ode:exercises'),
              (u'Упражнение 1: \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0440\u044f\u0434\u0430 \u0422\u0435\u0439\u043b\u043e\u0440\u0430 \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f $y^1$',
               2,
               u'fdm-for-ode:exercises:1',
               u'fdm-for-ode:exercises:1'),
              (u'Задача 2: \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043b\u0438\u043d\u0435\u0439\u043d\u043e\u0439 \u0438 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0438\u0447\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u0434\u043b\u044f \u0442\u0435\u0441\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f',
               2,
               u'fdm-for-ode:exercises:pr:1',
               u'fdm-for-ode:exercises:pr:1')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<a name="part0001"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._fdm-for-ode-solarized000.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._fdm-for-ode-solarized002.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="fdm-for-ode:fdd">Конечно-разностная дискретизация</h1>

<p>
Многие вычислительные проблемы, возникающие при вычислении
осциллирующих решений обыкновенных дифференциальных уравнений и
уравнений в частных производных могут быть проиллюстрированы на
простейшем ОДУ второго порядка \( u'' + \omega^2 u = 0 \).

<h2 id="fdm-for-ode:fdd:basic_model">Базовая модель колебательного процесса</h2>

<p>
Колебательная система без затуханий и внешних сил может быть описана
начальной задачей для ОДУ второго порядка

$$
\begin{align}
\tag{1}
   u'' + \omega^2 u = 0, \quad t \in (0, T],\\
\tag{2}
	u(0) = U,\quad  u'(0) = 0.
\end{align}
$$

<p>
Здесь \( \omega \) и \( U \) --- заданные постоянные. Точное
решение задачи <a href="#mjx-eqn-1">(1)</a> &ndash;
<a href="#mjx-eqn-2">(2)</a> имеет вид 

$$
\begin{equation}
\tag{3}
	u(t) = U\cos{\omega t},
\end{equation}
$$

<p>
т.е. \( u \) описывает колебания с постоянной амплитудой \( U \) и
угловой частотой \( \omega \). Соответствующий период колебаний равен
\( P = 2\pi/\omega \). Число периодов в секунду --- это
\( f = \omega/2\pi \). Оно измеряется в герцах (Гц). Как \( f \),
так и \( \omega \) описываются частоту колебаний, но \( \omega \)
более точно называется <em>угловой частотой</em> и измеряется в радиан/с.

<p>
В колебательных механических системах, описываемых задачей
<a href="#mjx-eqn-1">(1)</a> &ndash;
<a href="#mjx-eqn-2">(2)</a> \( u \) часто представляет собой

<p>
координату или смещение точки в системе. Производная \( u'(t) \), таким
образом, интерпретируется как скорость, а \( u''(t) \) ---
ускорение. Задача <a href="#mjx-eqn-1">(1)</a> &ndash; 
<a href="#mjx-eqn-2">(2)</a> описывает не только
механические колебания, но и колебания в электрических цепях.

<h2 id="fdm-for-ode:fdd:fdd">Разностная схема</h2>

<p>
При численном решении задачи <a href="#mjx-eqn-1">(1)</a> &ndash;
<a href="#mjx-eqn-2">(2)</a> будем
использовать равномерную сетку по переменной \( t \) с шагом
\( \tau \):

$$
   \omega_\tau = \{ t_n = n\tau, \ n = 0, 1, \ldots N \}.
$$

<p>
Приближенное решение задачи <a href="#mjx-eqn-1">(1)</a> &ndash;
<a href="#mjx-eqn-2">(2)</a> в точке
\( t_n \) обозначим \( y^n \).

<p>
Простейшая разностная схема для приближенного решения задачи <a href="#mjx-eqn-1">(1)</a> &ndash;
<a href="#mjx-eqn-2">(2)</a> есть

$$
\begin{equation}
\tag{4}
   \frac{y^{n+1} - 2 y^{n} + y^{n-1}}{\tau^2} = -\omega^2 y^n.
\end{equation}
$$

<p>
Кроме того необходимо аппроксимировать производную во втором начальном
условии. Будем аппроксимировать ее центральную разностную производную:

$$
\begin{equation}
\tag{5}
   \frac{y^1 - y^{-1}}{2\tau} = 0.
\end{equation}
$$

<p>
Для формулировки вычислительного алгоритма, предположим, что мы уже
знаем значение \( y^{n-1} \) и \( y^{n} \). Тогда из
<a href="#mjx-eqn-4">(4)</a> мы можем выразить неизвестное значение
\( y^{n+1} \):

$$
\begin{equation}
\tag{6}
   y^{n+1} = 2y^n - y^{n-1} - \tau^2 \omega^2 y^n.
\end{equation}
$$

<p>
Вычислительный алгоритм заключается в последовательном применении
для \( n = 1, 2, \ldots \).

<p>
Очевидно, что <a href="#mjx-eqn-6">(6)</a>  нельзя
использовать при \( n = 0 \), так как для вычисления \( y^1 \) необходимо знать неопределенное
значение \( y^{-1} \) при \( t = -\tau \). Однако, из <a href="#mjx-eqn-5">(5)</a>
имеем \( y^{-1} = y^{1} \). Подставляя последнее в <a href="#mjx-eqn-6">(6)</a>
при \( n=0 \), получим

$$
\begin{equation*}
   y^1 = 2 y^0 - y^1 - \tau^2 \omega^2 y^0,
\end{equation*}
$$

откуда

$$
\begin{equation}
\tag{7}
   y^1 = y^0 - \frac{1}{2} \tau^2\omega^2 y^0.
\end{equation}
$$

<p>
В <a href="._fdm-for-ode-solarized002.html#fdm-for-ode:exercises:1">Упражнение 1: Использование ряда Тейлора для вычисления \( y^1 \)</a> требуется использовать
альтернативный способ вывода <a href="#mjx-eqn-7">(7)</a>, а также построить
аппроксимацию начального условия \( u'(0) = V \ne 0 \).

<h2 id="fdm-for-ode:fdd:alg">Вычислительный алгоритм</h2>

<p>
Для решения задачи <a href="#mjx-eqn-1">(1)</a> &ndash;
<a href="#mjx-eqn-2">(2)</a> следует выполнить
следующие шаги:

<ol>
<li> \( y^0 = U \)</li>
<li> вычисляем \( y^1 \), используя <a href="#mjx-eqn-7">(7)</a></li>
<li> для \( n = 1, 2, \ldots \),

<ol type="a"></li>
   <li> вычисляем \( y^n \), используя <a href="#mjx-eqn-6">(6)</a></li>
</ol>

</ol>

Более строго вычислительный алгоритм напишем на Python:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>t = linspace(0, T, N+1)  # сетка по времени
tau = t[1] - t[0]        # постоянный временной шаг
u = zeros(N+1)           # решение
   
u[0] = U
u[1] = u[0] - 0.5*tau**2*omega**2*u[0]
for n in range(1, N):
    u[n+1] = 2*u[n] - u[n-1] - tau**2*omega**2*u[n]
</code></pre>
<!-- end verbatim block -->

<h2 id="fdm-for-ode:fdd:index_free">Безындексные обозначения</h2>

<p>
Разностную схему можно записать, используя безындексные
обозначения. Для <em>левой</em> и <em>правой разностных производных</em> соответственно
имеем 

$$
\begin{equation*}
   y_{\bar{t}} \equiv \frac{y^{n} - y^{n-1}}{\tau}, \quad
   y_{t} \equiv \frac{y^{n+1} - y^{n}}{\tau}.
\end{equation*}
$$

<p>
Для <em>второй разностной производной</em> получим

$$
\begin{equation*}
   y_{\bar{t}t} = \frac{y_t - y_{\bar{t}}}{\tau} = \frac{y^{n+1} - 2y^{n} + y^{n-1}}{\tau^2}.
\end{equation*}
$$

<p>
Для аппроксимации второго начального условия использовалась
<em>центральная разностная производная</em>:

$$
\begin{equation*}
   y_{\mathring{t}} = \frac{y^{n+1} - y^{n-1}}{2\tau}.
\end{equation*}
$$

<p>
<!-- Local Variables: -->
<!-- doconce-chapter-nickname: "fdm-for-ode" -->
<!-- doconce-section-nickname: "fdd" -->
<!-- End: -->

<h1 id="fdm-for-ode:impl">Программная реализация</h1>

<h2 id="fdm-for-ode:impl:solver">Функция-решатель (Солвер)</h2>

<p>
Алгоритм построенный в предыдущем разделе легко записать как
функцию Python, вычисляющую \( y^0, y^1, \ldots, y^{N} \) по
заданным входным параметрам \( U, \omega, \tau \) и \( T \):

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def solver(U, omega, tau, T):
    &quot;&quot;&quot;
    Решается задача
    u'' + omega**2*u = 0 для t из (0,T], u(0)=U и u'(0)=0,
    конечно-разностным методом с постоянным шагом tau
    &quot;&quot;&quot;
    tau = float(tau)
    Nt = int(round(T/tau))
    u = np.zeros(Nt+1)
    t = np.linspace(0, Nt*tau, Nt+1)

    u[0] = U
    u[1] = u[0] - 0.5*tau**2*omega**2*u[0]
    for n in range(1, Nt):
        u[n+1] = 2*u[n] - u[n-1] - tau**2*omega**2*u[n]
    return u, t
</code></pre>
<!-- end verbatim block -->

<p>
Также будет удобно реализовать функцию для построения графиков точного
и приближенного решений:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def visualize(u, t, U, omega):
    plt.plot(t, u, 'r--o')
    t_fine = np.linspace(0, t[-1], 1001)  # мелкая сетка для точного решения
    u_e = u_exact(t_fine, U, omega)
    plt.hold('on')
    plt.plot(t_fine, u_e, 'b-')
    plt.legend([u'приближенное', u'точное'], loc='upper left')
    plt.xlabel('$t$')
    plt.ylabel('$u$')
    tau = t[1] - t[0]
    plt.title('$\\tau = $ %g' % tau)
    umin = 1.2*u.min();  umax = -umin
    plt.axis([t[0], t[-1], umin, umax])
    plt.savefig('tmp1.png');  plt.savefig('tmp1.pdf')
</code></pre>
<!-- end verbatim block -->

<p>
Соответствующая основная программа вызывающая эти функции для
моделирования заданного числа периодов (<code>num_periods</code>) может иметь
вид

<p>
<!-- begin verbatim block  pycod-->
<pre><code>U = 1
omega = 2*pi
tau = 0.05
num_periods = 5
P = 2*np.pi/tau    #  один период
T = P*num_periods
u, t = solver(U, omega, tau, T)
visualize(u, t, U, omega, tau)
</code></pre>
<!-- end verbatim block -->

<p>
Задание некоторых входных параметров удобно осуществлять через
командную строку. Ниже представлен фрагмент кода, использующий
инструмент <code>ArgumentParser</code> из модуля <code>argparse</code> для определения 
пар "параметр значение" (<code>--option value</code>) в командной строке:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--U', type=float, default=1.0)
parser.add_argument('--omega', type=float, default=2*np.pi)
parser.add_argument('--tau', type=float, default=0.05)
parser.add_argument('--num_periods', type=int, default=5)
a = parser.parse_args()
U, omega, tau, num_periods = a.U, a.omega, a.tau, a.num_periods
</code></pre>
<!-- end verbatim block -->

<p>
Стандартный вызов основной программы выглядит следующим образом:
<!-- begin verbatim block  shcod-->
<pre><code>Terminal&gt; python vib_undamped.py --num_periods 20 --tau 0.1
</code></pre>
<!-- end verbatim block -->

<h2 id="fdm-for-ode:impl:comp_diff">Вычисление производной \( u'(t) \)</h2>

<p>
В приложениях часто необходимо анализировать поведение скорости
\( u'(t) \). Приближенно найти ее по полученным в 
узлах сетки \( \omega_\tau \) значениям \( y \) можно, например,
используя центральную разностную производную:

$$
\begin{equation}
\tag{8}
   u'(t_n) \approx v^n = \frac{y^{n+1} - y^n}{2\tau} =
   y_{\mathring{t}}^n.
\end{equation}
$$

<p>
Эта формула используется во внутренних узлах сетки \( \omega_\tau \)
при \( n = 1, 2, \ldots, N-1 \). Для \( n = 0 \) скорость
\( v^0 \) задана начальным условием, а для \( n = N \) мы можем использовать
направленную (левую) разностную производную \( v^N = y_{\bar{t}}^N \).

<p>
Для вычисления производной можно использовать следующий (скалярный)
код:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>v = np.zeros_like(u)  # or v = np.zeros(len(u))
# Используем центральную разностную производную во внутренних узлах
for i in range(1, len(u)-1):
v[i] = (u[i+1] - u[i-1])/(2*tau)
# Используем начальное условие для u'(0)
v[0] = 0
# Используем левую разностную производную
v[-1] = (u[-1] - u[-2])/tau
</code></pre>
<!-- end verbatim block -->

<p>
Мы можем избавиться от цикла (медленного для больших \( N \)),
векторизовав вычисление разностной производной. Фрагмент кода,
приведенного выше, можно заменить следующей векторизованной формой:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>v = np.zeros_like(u)
v[1:-1] = (u[2:] - u[:-2])/(2*tau)  # центральная разностная производная
v[0] = 0                            # начальное условие u'(0)
v[-1] = (u[-1] - u[-2])/tau         # левая разностная производная
</code></pre>
<!-- end verbatim block -->

<p>
<!-- Local Variables: -->
<!-- doconce-chapter-nickname: "fdm-for-ode" -->
<!-- doconce-section-nickname: "impl" -->
<!-- End: -->

<h1 id="fdm-for-ode:verif">Верификация реализации алгоритма</h1>

<h2 id="fdm-for-ode:verif:hand">Вычисления в ручную</h2>

<p>
Простейший способ проверки правильности реализации алгоритма
заключается в вычислении значений \( y^1, y^2 \) и \( y^3 \),
например с помощью калькулятора и в написании функции, сравнивающей
эти результаты с соответствующими результатами вычисленными с помощью
функции <code>solver</code>. Представленная ниже функция <code>test_three_steps</code>
демонстрирует, как можно использовать "ручные" вычисления для
тестирования кода:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_three_steps():
    from math import pi
    U = 1;  omega = 2*pi;  tau = 0.1;  T = 1
    u_by_hand = np.array([
	    1.000000000000000,
	    0.802607911978213,
	    0.288358920740053])
    u, t = solver(U, omega, tau, T)
    diff = np.abs(u_by_hand - u[:3]).max()
    tol = 1E-14
    assert diff &lt; tol
</code></pre>
<!-- end verbatim block -->

<h2 id="fdm-for-ode:verif:">Тестирование на простейших решениях</h2>

<p>
Построение тестовой задачи, решением которой является постоянная
величина или линейная функция, помогает выполнять начальную отладку и
проверку реализации алгоритма, так как соответствующие вычислительные
алгоритмы воспроизводят такие решения с машинной точностью. Например,
методы второго порядка точности часто являются точными на полиномах
второй степени. Возьмем точное значение второй разностной производной
\( (t^2)_{\bar{t}t}^n = 2 \). Решение \( u(t) = t^2 \) дает
\( u'' + \omega^2 u = 2 + (\omega t)^2 \ne 0 \). Следовательно,
необходимо добавить функцию источника в уравнение:
\( u'' + \omega^2 u = f \). Такое уравнение имеет решение
\( u(t) = t^2 \) при \( f(t) = (\omega t)^2 \). Простой
подстановкой убеждаемся, что сеточная функция \( y^n = t_n^2 \)
является решением разностной схемы. Выполните
<a href="._fdm-for-ode-solarized002.html#fdm-for-ode:exercises:pr:1">Задача 2: Использование линейной и квадратичной функций для тестирования</a>.

<h2 id="fdm-for-ode:verif:conv">Анализ скорости сходимости</h2>

<p>
Естественно ожидать, что погрешность метода \( \varepsilon \) должна
уменьшаться с уменьшением шага \( \tau \). Многие вычислительные
методы (в том числе и конечно-разностные) имеют степенную зависимость
погрешности \( \varepsilon \) от \( \tau \):

$$
\begin{equation}
\tag{9}
	\varepsilon = M \tau^r,
\end{equation}
$$

где \( C \) и \( r \) --- постоянные (обычно неизвестные), не
зависящие от \( \tau \). Формула <a href="#mjx-eqn-9">(9)</a>
является асимптотическим законом, верным при достаточно малом
параметре \( \tau \). Насколько малом оценить сложно без численной оценки
параметра \( r \).

<p>
Параметр \( r \) называется <em>скоростью сходимости</em>.

<h3 id="fdm-for-ode:verif:conv:est">Оценка скорости сходимости</h3>

<p>
Чтобы оценить скорость сходимости для рассматриваемой задачи, нужно
выполнить

<ul>
<li> провести \( m \) расчетов, уменьшая на каждом из них шаг в два раза:
  \( \tau_k = 2^{-k}\tau_0 \), \( k = 0, 1, \ldots, m-1 \),</li> 
<li> вычислить \( L_2 \) -норму погрешности для каждого расчета
  \( \varepsilon_k = \sqrt{\sum_{n=0}^{N-1} (y^n -u_e(t_n)) \tau_k} \),</li>
<li> оценить скорость сходимости на основе двух последовательных
  экспериментов \( (\tau_{k-1}, \varepsilon_{k-1}) \) и
  \( (\tau_{k}, \varepsilon_{k}) \), в предположении, что погрешность подчинена закону
  <a href="#mjx-eqn-9">(9)</a>. Разделив \( \varepsilon_{k-1} = M\tau_{k-1}^r \)
  на \( \varepsilon_{k} = M\tau_{k}^r \) и решая получившееся
  уравнение относительно \( r \), получим</li>
</ul>

$$
	r_{k-1} =
	\frac{\ln(\varepsilon_{k-1}/\varepsilon_k)}{\ln(\tau_{k-1}/\tau_k)},
	\quad k = 0, 1, \ldots, m-1.
$$

<p>
Будем надеяться, что полученные значения \( r_0, r_1, \ldots,  r_{m-2} \)
сходятся к некоторому числу (в нашем случае к 2).

<h3 id="fdm-for-ode:verif:conv:impl">Программная реализация</h3>

<p>
Ниже приведена функция для вычисления последовательности \( r_0,
r_1, \ldots, r_{m-2} \).

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def convergence_rates(m, solver_function, num_periods=8):
    &quot;&quot;&quot;
    Возвращает m-1 эмпирическую оценку скорости сходимости, 
    полученную на основе m расчетов, для каждого из которых 
    шаг по времени уменьшается в два раза.
    solver_function(U, omega, tau, T) решает каждую задачу, 
    для которой T, получается на основе вычислений для 
    num_periods периодов.
    &quot;&quot;&quot;
    from math import pi
    omega = 0.35; U = 0.3       # просто заданные значения
    P = 2*pi/omega              # период
    tau = P/30                  # 30 шагов на период 2*pi/omega
    T = P*num_periods

    tau_values = []
    E_values = []
    for i in range(m):
        u, t = solver_function(U, omega, tau, T)
        u_e = u_exact(t, U, omega)
        E = np.sqrt(tau*np.sum((u_e-u)**2))
        tau_values.append(tau)
        E_values.append(E)
        tau = tau/2

    r = [np.log(E_values[i-1]/E_values[i])/
         np.log(tau_values[i-1]/tau_values[i])
         for i in range(1, m, 1)]
    return r
</code></pre>
<!-- end verbatim block -->

<p>
Ожидаемая скорость сходимости --- 2, так как мы используем
конечно-разностную аппроксимации второго порядка для второй
производной в уравнении и для первого начального
условия. Теоретический анализ погрешности аппроксимации дает
\( r=2 \).

<p>
Для рассматриваемой задачи, когда \( \tau_0 \) соответствует 30
временным шагам на период, возвращаемый список <code>r</code> содержит элементы
равные <code>2.00</code>. Это означает, что все значения \( \tau_k \)
удовлетворяют ассимтотическому режиму, при котором выполнено
соотношение <a href="#mjx-eqn-9">(9)</a>

<p>
Теперь мы можем написать тестовую функцию, которая вычисляет скорости
сходимости и проверяет, что последняя оценка достаточно близка
к 2. Здесь достаточна граница допуска 0.1.

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def test_convergence_rates():
    r = convergence_rates(m=5, solver_function=solver, num_periods=8)
    tol = 0.1
    assert abs(r[-1] - 2.0) &lt; tol
</code></pre>
<!-- end verbatim block -->

<h1 id="fdm-for-ode:scaled">Безразмерная модель</h1>

<p>
При моделировании полезно использовать безразмерные переменные, так
как в этом случае нужно задавать меньше параметров. Рассматриваемая
нами задача обезразмеривается заданием переменных \( \bar{t} = t/t_c \) и
\( \bar{u} = u/u_c \), где \( t_c \) и \( u_c \)
характерные масштабы для \( t \) и \( u \),
соответственно. Задача для ОДУ принимает вид

$$
   \frac{u_c}{t_c} \frac{d^2 \bar{u}}{d \bar{t}^2} + u_c \bar{u} = 0,
   \quad u_c \bar{u}(0) = U, \quad  \frac{u_c}{t_c} \frac{d \bar{u}}{d
   \bar{t}}(0) = 0.
$$

<p>
Обычно в качестве \( t_c \) выбирается один период колебаний,
т.е. \( t_c = 2\pi/\omega \) и \( u_c = U \). Отсюда получаем
безразмерную модель

$$
\begin{equation}
\tag{10}
   \frac{d^2 \bar{u}}{d \bar{t}^2} + 4\pi^2 \bar{u} = 0, \quad
   \bar{u}(0) = 1, \quad \bar{u}'(0) = 0.
\end{equation}
$$

<p>
Заметьте, что в <a href="#mjx-eqn-10">(10)</a> отсутствуют физические
параметры. Таким образом мы можем выполнить одно вычисление
\( \bar{u}(\bar{t}) \) и затем восстановить любое \( u(t; \omega,U) \)
следующим образом

$$
   u(t; \omega, U) = u_c \bar{u}(t/t_c) = U \bar{u}(\omega t/(2\pi)).
$$

<p>
Расчет для безразмерной модели можно выполнить вызвав функцию
<code>solver(U = 1, omega = 2*np.pi, tau, T)</code>. В этом случае период равен
1 и <code>T</code> задает количество периодов. Выбор <code>tau = 1./N</code> дает
\( N \) шагов на период.

<p>
Сценарий  <a href="src-fdm-for-ode/vib_undamped.py.html" target="_self">vib_undamped.py</a>
(<a href="src-fdm-for-ode/vib_undamped.py" target="_self">скачать</a>). 
содержит представленные в данном разделе примеры.

<p>
<!-- Local Variables: -->
<!-- doconce-chapter-nickname: "fdm-for-ode" -->
<!-- doconce-section-nickname: "verif" -->
<!-- End: -->

<h1 id="fdm-for-ode:long_time">Проведение вычислительного эксперимента</h1>

<p>
На рисунке <a href="#fdm-for-ode:long_time:fig:1">1</a> представлено сравнение
точного и приближенного решений безразмерной модели
<a href="#mjx-eqn-10">(10)</a> с шагами \( \tau=0.1 \) и
\( 0.5 \). Проанализировав графики, мы можем 
сделать следующие предположения:

<ul>
<li> Похоже, что численное решение корректно передает амплитуду колебаний</li>
<li> Наблюдается погрешность при расчете угловой частоты, которая
  уменьшается при уменьшении шага.</li>
<li> Суммарная погрешность угловой частоты увеличивается со временем.</li>
</ul>

<center> <!-- figure label: --> <div id="fdm-for-ode:long_time:fig:1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Рисунок 1:  Эффект от уменьшения шага вдвое  <!-- caption label: fdm-for-ode:long_time:fig:1 --> </p></center>
<p><img src="fig-fdm-for-ode/vib-fig-1.png" align="bottom" width=800></p>
</center>

<h2 id="fdm-for-ode:long_time:mov_figs">Использование изменяющихся графиков</h2>

<p>
В рассматриваемой нами задаче о колебаниях следует анализировать
поведение системы на больших временных интервалах. Как видно из
предыдущих наблюдений погрешность угловой частоты накапливается и
становится более различимой со временем. Мы можем провести анализ на
большом интервале времени, построив подвижные графики, которые могут
изменяться в течение \( p \) новых вычисленных периодах
решения. Пакет <a href="https://github.com/hplgit/scitools" target="_self">SciTools</a>
содержит удобный инструмент для этого: <code>MovingPlotWindow</code>. Ниже
приведена функция, использующая данный инструмент:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def visualize_front(u, t, U, omega, savefig=False, skip_frames=1):
    &quot;&quot;&quot;
    Стороится зависимость приближенного и точного решений
    от t с использованием анимированного изображения и непрерывного
    отображения кривых, изменяющихся со временем.
    Графики сохраняются в файлы, если параметр savefig=True.
    Только каждый skip_frames-й график сохраняется (например, если 
    skip_frame=10, только каждый десятый график сохраняется в файл;
    это удобно, если нужно сравнивать графики для различных моментов
    времени).
    &quot;&quot;&quot;
    import scitools.std as st
    from scitools.MovingPlotWindow import MovingPlotWindow
    from math import pi

    # Удаляем все старые графики tmp_*.png
    import glob, os
    for filename in glob.glob('tmp_*.png'):
        os.remove(filename)

    P = 2*pi/omega  # один период
    umin = 1.2*u.min();  umax = -umin
    tau = t[1] - t[0]
    plot_manager = MovingPlotWindow(
        window_width=8*P,
        dt=tau,
        yaxis=[umin, umax],
        mode='continuous drawing')
    frame_counter = 0
    for n in range(1,len(u)):
        if plot_manager.plot(n):
            s = plot_manager.first_index_in_plot
            st.plot(t[s:n+1], u[s:n+1], 'r-1',
                    t[s:n+1], U*np.cos(omega*t)[s:n+1], 'b-1',
                    title='t=%6.3f' % t[n],
                    axis=plot_manager.axis(),
                    show=not savefig) # пропускаем окно, если savefig
            if savefig and n % skip_frames == 0:
                filename = 'tmp_%04d.png' % frame_counter
                st.savefig(filename)
                print u'Создаем графический файл', filename, 't=%g' % t[n]
                frame_counter += 1
        plot_manager.update(n)
</code></pre>
<!-- end verbatim block -->

<p>
Можно вызывать эту функцию в функции <code>main</code>, если число периодов при
моделировании больше 10. Запуск вычислений для безразмерной
модели (значения, заданные по умолчанию, для аргументов командной
строки <code>--U</code> и <code>--omega</code> соответствуют безразмерной модели) для 40
периодов с 20 шагами на период выглядит следующим образом

<p>
<!-- begin verbatim block  shcod-->
<pre><code>Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40
</code></pre>
<!-- end verbatim block -->

<p>
Появится окно с движущимся графиком, на котором мы можем видеть
изменение точного и приближенного решений со временем. На этих
графиках мы видим, что погрешность угловой частоты мала в начале
расчета, но становится более заметной со временем.

<h2 id="fdm-for-ode:long_time:anim">Создание анимации</h2>

<h3 id="fdm-for-ode:long_time:anim:std">Стандартные видео форматы</h3>

<p>
Функция <code>visualize_front</code> сохраняет все графики в файлы с именами:
<code>tmp_0000.png</code>, <code>tmp_0001.png</code>, <code>tmp_0002.png</code> и т.д. Из этих
файлов мы можем создать видео файл, например, в формате <code>mpeg4</code>:

<p>
<!-- begin verbatim block  shcod-->
<pre><code>Terminal&gt; ffmpeg -r 12 -i tmp_%04d.png -c:v libx264 movie.mp4
</code></pre>
<!-- end verbatim block -->

<p>
Программа <code>ffmpeg</code> имеется в репозитариях Ubuntu. Можно использовать
другие программы для создания видео из набора отдельных графических
файлов. Для генерации других видео форматов с помощью <code>ffmpeg</code> можно
использовать  соответствующие кодеки и расширения для выходных файлов:

<p>
<table border="1">
<thead>
<tr><th align="center">Формат</th> <th align="center">          Кодек и имя файла          </th> </tr>
</thead>
<tbody>
<tr><td align="left">   Flash     </td> <td align="left">   <code>-c:v flv movie.flv</code>          </td> </tr>
<tr><td align="left">   MP4       </td> <td align="left">   <code>-c:v libx264 movie.mp4</code>      </td> </tr>
<tr><td align="left">   WebM      </td> <td align="left">   <code>-c:v libx264 movie.mp4</code>      </td> </tr>
<tr><td align="left">   Ogg       </td> <td align="left">   <code>-c:v libtheora movie.ogg</code>    </td> </tr>
</tbody>
</table>
<p>
Видео файл можно проиграть каким-либо видео плейером.

<p>
Также можно использовать веб-браузер, создав веб-страницу, содержащую HTML5-тег
<code>video</code>:

<p>
<!-- begin verbatim block  htmlcod-->
<pre><code>&lt;video autoplay loop controls width='640' height='365' preload='none'&gt;
	   &lt;source src='movie.webm'  type='video/webm; codecs=&quot;vp8, vorbis&quot;'&gt;
&lt;/video&gt;
</code></pre>
<!-- end verbatim block -->

<p>
Современные браузеры поддерживают не все видео форматы. MP4 необходим
для просмотра на устройствах Apple, которые используют браузер
Safari. WebM --- предпочтительный формат для Chrome, Opera, Firefox и
IE v9+. Flash был популярен раньше, но старые браузеры, которые
использовали Flash могут проигрывать MP4. Все браузеры, которые
работают с форматом Ogg, могут также воспроизводить WebM. Это
означает, что для того, чтобы видео можно было просмотреть в любом
браузере, это видео должно быть доступно в форматах MP4 и
WebM. Соответствующий HTML код представлен ниже:

<p>
<!-- begin verbatim block  htmlcod-->
<pre><code>&lt;video autoplay loop controls width='640' height='365' preload='none'&gt;
   &lt;source src='movie.mp4'   type='video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;'&gt; 
   &lt;source src='movie.webm'  type='video/webm; codecs=&quot;vp8,	vorbis&quot;'&gt;
&lt;/video&gt;
</code></pre>
<!-- end verbatim block -->

<p>
Формат MP4 должен идти первым для того, чтобы устройства Apple могли
корректно загружать видео.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Предупреждение.</b>
<p>
Для того, чтобы быть уверенным в том, что отдельные графические
кадры в итоге показывались в правильном порядке, необходимо
нумеровать файлы используя нули вначале номера (0000, 0001, 0002 и
т.д.). Формат <code>%04d</code> задает отображение целого числа в поле из 4
символов, заполненном слева нулями.
</div>


<p>
<!-- Local Variables: -->
<!-- doconce-chapter-nickname: "fdm-for-ode" -->
<!-- doconce-section-nickname: "long_time" -->
<!-- End: -->
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._fdm-for-ode-solarized000.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._fdm-for-ode-solarized002.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

